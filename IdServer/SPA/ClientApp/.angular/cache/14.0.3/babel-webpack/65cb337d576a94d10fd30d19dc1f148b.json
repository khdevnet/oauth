{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, NgModule, inject } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, Observable, throwError, timer, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, take, switchMap, retryWhen, catchError, retry, concatMap, finalize, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  get(url, params) {\n    return this.http.get(url, params);\n  }\n\n  post(url, body, params) {\n    return this.http.post(url, body, params);\n  }\n\n}\n\nHttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n  return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nHttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HttpBaseService,\n  factory: HttpBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HttpBaseService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }];\n  }, null);\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\n\nclass DataService {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  get(url, config, token) {\n    const headers = this.prepareHeaders(token);\n    const params = this.prepareParams(config);\n    return this.httpClient.get(url, {\n      headers,\n      params\n    });\n  }\n\n  post(url, body, config, headersParams) {\n    const headers = headersParams || this.prepareHeaders();\n    const params = this.prepareParams(config);\n    return this.httpClient.post(url, body, {\n      headers,\n      params\n    });\n  }\n\n  prepareHeaders(token) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Accept', 'application/json');\n\n    if (!!token) {\n      headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n    }\n\n    return headers;\n  }\n\n  prepareParams(config) {\n    let params = new HttpParams();\n    const {\n      ngswBypass\n    } = config;\n\n    if (ngswBypass) {\n      params = params.set(NGSW_CUSTOM_PARAM, '');\n    }\n\n    return params;\n  }\n\n}\n\nDataService.ɵfac = function DataService_Factory(t) {\n  return new (t || DataService)(i0.ɵɵinject(HttpBaseService));\n};\n\nDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DataService,\n  factory: DataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: HttpBaseService\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes;\n\n(function (EventTypes) {\n  /**\r\n   *  This only works in the AppModule Constructor\r\n   */\n  EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n  EventTypes[EventTypes[\"CheckingAuth\"] = 1] = \"CheckingAuth\";\n  EventTypes[EventTypes[\"CheckingAuthFinished\"] = 2] = \"CheckingAuthFinished\";\n  EventTypes[EventTypes[\"CheckingAuthFinishedWithError\"] = 3] = \"CheckingAuthFinishedWithError\";\n  EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 4] = \"ConfigLoadingFailed\";\n  EventTypes[EventTypes[\"CheckSessionReceived\"] = 5] = \"CheckSessionReceived\";\n  EventTypes[EventTypes[\"UserDataChanged\"] = 6] = \"UserDataChanged\";\n  EventTypes[EventTypes[\"NewAuthenticationResult\"] = 7] = \"NewAuthenticationResult\";\n  EventTypes[EventTypes[\"TokenExpired\"] = 8] = \"TokenExpired\";\n  EventTypes[EventTypes[\"IdTokenExpired\"] = 9] = \"IdTokenExpired\";\n  EventTypes[EventTypes[\"SilentRenewStarted\"] = 10] = \"SilentRenewStarted\";\n  EventTypes[EventTypes[\"SilentRenewFailed\"] = 11] = \"SilentRenewFailed\";\n})(EventTypes || (EventTypes = {}));\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n  LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel || (LogLevel = {}));\n/**\r\n * Implement this class-interface to create a custom logger service.\r\n */\n\n\nclass AbstractLoggerService {}\n\nAbstractLoggerService.ɵfac = function AbstractLoggerService_Factory(t) {\n  return new (t || AbstractLoggerService)();\n};\n\nAbstractLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractLoggerService,\n  factory: AbstractLoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractLoggerService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass LoggerService {\n  constructor(abstractLoggerService) {\n    this.abstractLoggerService = abstractLoggerService;\n  }\n\n  logError(configuration, message, ...args) {\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  logWarning(configuration, message, ...args) {\n    if (!this.logLevelIsSet(configuration)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Warn)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  logDebug(configuration, message, ...args) {\n    if (!this.logLevelIsSet(configuration)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Debug)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  currentLogLevelIsEqualOrSmallerThan(configuration, logLevelToCompare) {\n    const {\n      logLevel\n    } = configuration || {};\n    return logLevel <= logLevelToCompare;\n  }\n\n  logLevelIsSet(configuration) {\n    const {\n      logLevel\n    } = configuration || {};\n\n    if (logLevel === null) {\n      return false;\n    }\n\n    if (logLevel === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  loggingIsTurnedOff(configuration) {\n    const {\n      logLevel\n    } = configuration || {};\n    return logLevel === LogLevel.None;\n  }\n\n  isObject(possibleObject) {\n    return Object.prototype.toString.call(possibleObject) === '[object Object]';\n  }\n\n}\n\nLoggerService.ɵfac = function LoggerService_Factory(t) {\n  return new (t || LoggerService)(i0.ɵɵinject(AbstractLoggerService));\n};\n\nLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoggerService,\n  factory: LoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AbstractLoggerService\n    }];\n  }, null);\n})();\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nclass AbstractSecurityStorage {}\n\nAbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n  return new (t || AbstractSecurityStorage)();\n};\n\nAbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractSecurityStorage,\n  factory: AbstractSecurityStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractSecurityStorage, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass BrowserStorageService {\n  constructor(loggerService, abstractSecurityStorage) {\n    this.loggerService = loggerService;\n    this.abstractSecurityStorage = abstractSecurityStorage;\n  }\n\n  read(key, configuration) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to read '${key}' but Storage was undefined`);\n      return null;\n    }\n\n    const storedConfig = this.abstractSecurityStorage.read(configId);\n\n    if (!storedConfig) {\n      return null;\n    }\n\n    return JSON.parse(storedConfig);\n  }\n\n  write(value, configuration) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    value = value || null;\n    this.abstractSecurityStorage.write(configId, JSON.stringify(value));\n    return true;\n  }\n\n  remove(key, configuration) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to remove '${key}' but Storage was falsy`);\n      return false;\n    } // const storage = this.getStorage(configuration);\n    // if (!storage) {\n    //   this.loggerService.logDebug(configuration, `Wanted to write '${key}' but Storage was falsy`);\n    //   return false;\n    // }\n\n\n    this.abstractSecurityStorage.remove(key);\n    return true;\n  } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n  clear(configuration) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    } // const storage = this.getStorage(configuration);\n    // if (!storage) {\n    //   this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n    //   return false;\n    // }\n\n\n    this.abstractSecurityStorage.clear();\n    return true;\n  }\n\n  hasStorage() {\n    return typeof Storage !== 'undefined';\n  }\n\n}\n\nBrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n  return new (t || BrowserStorageService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AbstractSecurityStorage));\n};\n\nBrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserStorageService,\n  factory: BrowserStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserStorageService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AbstractSecurityStorage\n    }];\n  }, null);\n})();\n\nclass StoragePersistenceService {\n  constructor(browserStorageService) {\n    this.browserStorageService = browserStorageService;\n  }\n\n  read(key, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    return storedConfig[key];\n  }\n\n  write(key, value, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    storedConfig[key] = value;\n    return this.browserStorageService.write(storedConfig, config);\n  }\n\n  remove(key, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    delete storedConfig[key];\n    this.browserStorageService.write(storedConfig, config);\n  }\n\n  clear(config) {\n    this.browserStorageService.clear(config);\n  }\n\n  resetStorageFlowData(config) {\n    this.remove('session_state', config);\n    this.remove('storageSilentRenewRunning', config);\n    this.remove('storageCodeFlowInProgress', config);\n    this.remove('codeVerifier', config);\n    this.remove('userData', config);\n    this.remove('storageCustomParamsAuthRequest', config);\n    this.remove('access_token_expires_at', config);\n    this.remove('storageCustomParamsRefresh', config);\n    this.remove('storageCustomParamsEndSession', config);\n    this.remove('reusable_refresh_token', config);\n  }\n\n  resetAuthStateInStorage(config) {\n    this.remove('authzData', config);\n    this.remove('reusable_refresh_token', config);\n    this.remove('authnResult', config);\n  }\n\n  getAccessToken(config) {\n    return this.read('authzData', config);\n  }\n\n  getIdToken(config) {\n    var _a;\n\n    return (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.id_token;\n  }\n\n  getRefreshToken(config) {\n    var _a;\n\n    let refreshToken = (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.refresh_token;\n\n    if (!refreshToken && config.allowUnsafeReuseRefreshToken) {\n      return this.read('reusable_refresh_token', config);\n    }\n\n    return refreshToken;\n  }\n\n  getAuthenticationResult(config) {\n    return this.read('authnResult', config);\n  }\n\n}\n\nStoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n  return new (t || StoragePersistenceService)(i0.ɵɵinject(BrowserStorageService));\n};\n\nStoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoragePersistenceService,\n  factory: StoragePersistenceService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoragePersistenceService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: BrowserStorageService\n    }];\n  }, null);\n})();\n\nclass PublicEventsService {\n  constructor() {\n    this.notify = new ReplaySubject(1);\n  }\n  /**\r\n   * Fires a new event.\r\n   *\r\n   * @param type The event type.\r\n   * @param value The event value.\r\n   */\n\n\n  fireEvent(type, value) {\n    this.notify.next({\n      type,\n      value\n    });\n  }\n  /**\r\n   * Wires up the event notification observable.\r\n   */\n\n\n  registerForEvents() {\n    return this.notify.asObservable();\n  }\n\n}\n\nPublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n  return new (t || PublicEventsService)();\n};\n\nPublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PublicEventsService,\n  factory: PublicEventsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PublicEventsService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nfunction getVerifyAlg(alg) {\n  switch (alg.charAt(0)) {\n    case 'R':\n      return {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: 'SHA-256'\n      };\n\n    case 'E':\n      if (alg.includes('256')) {\n        return {\n          name: 'ECDSA',\n          hash: 'SHA-256'\n        };\n      } else if (alg.includes('384')) {\n        return {\n          name: 'ECDSA',\n          hash: 'SHA-384'\n        };\n      } else {\n        return null;\n      }\n\n    default:\n      return null;\n  }\n}\n\nfunction alg2kty(alg) {\n  switch (alg.charAt(0)) {\n    case 'R':\n      return 'RSA';\n\n    case 'E':\n      return 'EC';\n\n    default:\n      throw new Error('Cannot infer kty from alg: ' + alg);\n  }\n}\n\nfunction getImportAlg(alg) {\n  switch (alg.charAt(0)) {\n    case 'R':\n      if (alg.includes('256')) {\n        return {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: 'SHA-256'\n        };\n      } else if (alg.includes('384')) {\n        return {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: 'SHA-384'\n        };\n      } else if (alg.includes('512')) {\n        return {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: 'SHA-512'\n        };\n      } else {\n        return null;\n      }\n\n    case 'E':\n      if (alg.includes('256')) {\n        return {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        };\n      } else if (alg.includes('384')) {\n        return {\n          name: 'ECDSA',\n          namedCurve: 'P-384'\n        };\n      } else {\n        return null;\n      }\n\n    default:\n      return null;\n  }\n}\n\nconst PARTS_OF_TOKEN = 3;\n\nclass TokenHelperService {\n  constructor(loggerService, document) {\n    this.loggerService = loggerService;\n    this.document = document;\n  }\n\n  getTokenExpirationDate(dataIdToken) {\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\n      return new Date(new Date().toUTCString());\n    }\n\n    const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    date.setUTCSeconds(dataIdToken.exp);\n    return date;\n  }\n\n  getSigningInputFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return '';\n    }\n\n    const header = this.getHeaderFromToken(token, encoded, configuration);\n    const payload = this.getPayloadFromToken(token, encoded, configuration);\n    return [header, payload].join('.');\n  }\n\n  getHeaderFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 0, encoded);\n  }\n\n  getPayloadFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 1, encoded);\n  }\n\n  getSignatureFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 2, encoded);\n  }\n\n  getPartOfToken(token, index, encoded) {\n    const partOfToken = this.extractPartOfToken(token, index);\n\n    if (encoded) {\n      return partOfToken;\n    }\n\n    const result = this.urlBase64Decode(partOfToken);\n    return JSON.parse(result);\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        output += '==';\n        break;\n\n      case 3:\n        output += '=';\n        break;\n\n      default:\n        throw Error('Illegal base64url string!');\n    }\n\n    const decoded = typeof this.document.defaultView !== 'undefined' ? this.document.defaultView.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n    try {\n      // Going backwards: from byte stream, to percent-encoding, to original string.\n      return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    } catch (err) {\n      return decoded;\n    }\n  }\n\n  tokenIsValid(token, configuration) {\n    if (!token) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);\n      return false;\n    }\n\n    if (!token.includes('.')) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);\n      return false;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== PARTS_OF_TOKEN) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n      return false;\n    }\n\n    return true;\n  }\n\n  extractPartOfToken(token, index) {\n    return token.split('.')[index];\n  }\n\n}\n\nTokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n  return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(DOCUMENT));\n};\n\nTokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenHelperService,\n  factory: TokenHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwkExtractor {\n  static buildErrorName(name) {\n    return JwkExtractor.name + ': ' + name;\n  }\n\n  extractJwk(keys, spec, throwOnEmpty = true) {\n    if (0 === keys.length) {\n      throw JwkExtractor.InvalidArgumentError;\n    }\n\n    let foundKeys = keys.filter(k => (spec === null || spec === void 0 ? void 0 : spec.kid) ? k['kid'] === spec.kid : true).filter(k => (spec === null || spec === void 0 ? void 0 : spec.use) ? k['use'] === spec.use : true).filter(k => (spec === null || spec === void 0 ? void 0 : spec.kty) ? k['kty'] === spec.kty : true);\n\n    if (foundKeys.length === 0 && throwOnEmpty) {\n      throw JwkExtractor.NoMatchingKeysError;\n    }\n\n    if (foundKeys.length > 1 && (null === spec || undefined === spec)) {\n      throw JwkExtractor.SeveralMatchingKeysError;\n    }\n\n    return foundKeys;\n  }\n\n}\n\nJwkExtractor.InvalidArgumentError = {\n  name: JwkExtractor.buildErrorName('InvalidArgumentError'),\n  message: 'Array of keys was empty. Unable to extract'\n};\nJwkExtractor.NoMatchingKeysError = {\n  name: JwkExtractor.buildErrorName('NoMatchingKeysError'),\n  message: 'No key found matching the spec'\n};\nJwkExtractor.SeveralMatchingKeysError = {\n  name: JwkExtractor.buildErrorName('SeveralMatchingKeysError'),\n  message: 'More than one key found. Please use spec to filter'\n};\n\nJwkExtractor.ɵfac = function JwkExtractor_Factory(t) {\n  return new (t || JwkExtractor)();\n};\n\nJwkExtractor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwkExtractor,\n  factory: JwkExtractor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwkExtractor, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass CryptoService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getCrypto() {\n    // support for IE,  (window.crypto || window.msCrypto)\n    return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n  }\n\n}\n\nCryptoService.ɵfac = function CryptoService_Factory(t) {\n  return new (t || CryptoService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CryptoService,\n  factory: CryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwkWindowCryptoService {\n  constructor(cryptoService) {\n    this.cryptoService = cryptoService;\n  }\n\n  importVerificationKey(key, algorithm) {\n    return this.cryptoService.getCrypto().subtle.importKey('jwk', key, algorithm, false, ['verify']);\n  }\n\n  verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput) {\n    return this.cryptoService.getCrypto().subtle.verify(verifyAlgorithm, cryptoKey, signature, new TextEncoder().encode(signingInput));\n  }\n\n}\n\nJwkWindowCryptoService.ɵfac = function JwkWindowCryptoService_Factory(t) {\n  return new (t || JwkWindowCryptoService)(i0.ɵɵinject(CryptoService));\n};\n\nJwkWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwkWindowCryptoService,\n  factory: JwkWindowCryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwkWindowCryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }];\n  }, null);\n})();\n\nclass JwtWindowCryptoService {\n  constructor(cryptoService) {\n    this.cryptoService = cryptoService;\n  }\n\n  generateCodeChallenge(codeVerifier) {\n    return this.calcHash(codeVerifier).pipe(map(challengeRaw => this.base64UrlEncode(challengeRaw)));\n  }\n\n  generateAtHash(accessToken, algorithm) {\n    return this.calcHash(accessToken, algorithm).pipe(map(tokenHash => {\n      let substr = tokenHash.substr(0, tokenHash.length / 2);\n      const tokenHashBase64 = btoa(substr);\n      return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }));\n  }\n\n  calcHash(valueToHash, algorithm = 'SHA-256') {\n    const msgBuffer = new TextEncoder().encode(valueToHash);\n    return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map(hashBuffer => {\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return this.toHashString(hashArray);\n    }));\n  }\n\n  toHashString(byteArray) {\n    let result = '';\n\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n\n    return result;\n  }\n\n  base64UrlEncode(str) {\n    const base64 = btoa(str);\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n\n}\n\nJwtWindowCryptoService.ɵfac = function JwtWindowCryptoService_Factory(t) {\n  return new (t || JwtWindowCryptoService)(i0.ɵɵinject(CryptoService));\n};\n\nJwtWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtWindowCryptoService,\n  factory: JwtWindowCryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtWindowCryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }];\n  }, null);\n})(); // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nclass TokenValidationService {\n  constructor(tokenHelperService, loggerService, jwkExtractor, jwkWindowCryptoService, jwtWindowCryptoService, document) {\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.jwkExtractor = jwkExtractor;\n    this.jwkWindowCryptoService = jwkWindowCryptoService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n    this.document = document;\n    this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  hasIdTokenExpired(token, configuration, offsetSeconds) {\n    const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);\n    return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds);\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds) {\n    const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (!tokenExpirationDate) {\n      return false;\n    }\n\n    const tokenExpirationValue = tokenExpirationDate.valueOf();\n    const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n    const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n    return tokenNotExpired;\n  }\n\n  validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {\n    // value is optional, so if it does not exist, then it has not expired\n    if (!accessTokenExpiresAt) {\n      return true;\n    }\n\n    offsetSeconds = offsetSeconds || 0;\n    const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n    const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n    const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n    return tokenNotExpired;\n  } // iss\n  // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n  // https scheme that contains scheme, host,\n  // and optionally, port number and path components and no query or fragment components.\n  //\n  // sub\n  // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n  // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n  // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n  //\n  // aud\n  // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n  // audience value.\n  // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n  // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n  //\n  // exp\n  // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n  // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n  // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n  // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n  // the date/ time.\n  // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n  //\n  // iat\n  // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n  // 1970- 01 - 01T00: 00: 00Z as measured\n  // in UTC until the date/ time.\n\n\n  validateRequiredIdToken(dataIdToken, configuration) {\n    let validated = true;\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iss')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'sub')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'aud')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');\n    }\n\n    return validated;\n  } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n  // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n  validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {\n    if (disableIatOffsetValidation) {\n      return true;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\n      return false;\n    }\n\n    const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n    maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n    const nowInUtc = new Date(new Date().toUTCString());\n    const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n    const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n    this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n    if (diff > 0) {\n      return diff < maxOffsetAllowedInMilliseconds;\n    }\n\n    return -diff < maxOffsetAllowedInMilliseconds;\n  } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n  // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n  // The precise method for detecting replay attacks is Client specific.\n  // However the nonce claim SHOULD not be present for the refresh_token grant type\n  // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n  // The current spec is ambiguous and KeyCloak does send it.\n\n\n  validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {\n    const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n    if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n      return false;\n    }\n\n    return true;\n  } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n  // MUST exactly match the value of the iss (issuer) Claim.\n\n\n  validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {\n    if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n      return false;\n    }\n\n    return true;\n  } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n  // by the iss (issuer) Claim as an audience.\n  // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n  // not trusted by the Client.\n\n\n  validateIdTokenAud(dataIdToken, aud, configuration) {\n    if (Array.isArray(dataIdToken.aud)) {\n      const result = dataIdToken.aud.includes(aud);\n\n      if (!result) {\n        this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    } else if (dataIdToken.aud !== aud) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n      return false;\n    }\n\n    return true;\n  }\n\n  validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n    if (!dataIdToken) {\n      return false;\n    }\n\n    if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n      return false;\n    }\n\n    return true;\n  } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n  validateIdTokenAzpValid(dataIdToken, clientId) {\n    if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\n      return true;\n    }\n\n    if (dataIdToken.azp === clientId) {\n      return true;\n    }\n\n    return false;\n  }\n\n  validateStateFromHashCallback(state, localState, configuration) {\n    if (state !== localState) {\n      this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n      return false;\n    }\n\n    return true;\n  } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n  // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n  // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n  // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n  validateSignatureIdToken(idToken, jwtkeys, configuration) {\n    if (!idToken) {\n      return of(true);\n    }\n\n    if (!jwtkeys || !jwtkeys.keys) {\n      return of(false);\n    }\n\n    const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);\n\n    if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n      this.loggerService.logWarning(configuration, 'id token has no header data');\n      return of(false);\n    }\n\n    const kid = headerData.kid;\n    let alg = headerData.alg;\n    let keys = jwtkeys.keys;\n    let foundKeys;\n    let key;\n\n    if (!this.keyAlgorithms.includes(alg)) {\n      this.loggerService.logWarning(configuration, 'alg not supported', alg);\n      return of(false);\n    }\n\n    const kty = alg2kty(alg);\n    const use = 'sig';\n\n    try {\n      foundKeys = kid ? this.jwkExtractor.extractJwk(keys, {\n        kid,\n        kty,\n        use\n      }, false) : this.jwkExtractor.extractJwk(keys, {\n        kty,\n        use\n      }, false);\n\n      if (foundKeys.length === 0) {\n        foundKeys = kid ? this.jwkExtractor.extractJwk(keys, {\n          kid,\n          kty\n        }) : this.jwkExtractor.extractJwk(keys, {\n          kty\n        });\n      }\n\n      key = foundKeys[0];\n    } catch (e) {\n      this.loggerService.logError(configuration, e);\n      return of(false);\n    }\n\n    const algorithm = getImportAlg(alg);\n    const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);\n    const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);\n    const agent = this.document.defaultView.navigator.userAgent.toLowerCase();\n\n    if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\n      key.alg = '';\n    }\n\n    return from(this.jwkWindowCryptoService.importVerificationKey(key, algorithm)).pipe(mergeMap(cryptoKey => {\n      const signature = base64url.parse(rawSignature, {\n        loose: true\n      });\n      const verifyAlgorithm = getVerifyAlg(alg);\n      return from(this.jwkWindowCryptoService.verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput));\n    }), tap(isValid => {\n      if (!isValid) {\n        this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');\n      }\n    }));\n  } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n  //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n  ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n  ////    if (!header_data.hasOwnProperty('kid')) {\n  ////        // no kid defined in Jose header\n  ////        if (jwtkeys.keys.length != 1) {\n  ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n  ////            return false;\n  ////        }\n  ////    }\n  ////    return true;\n  //// }\n  // Access Token Validation\n  // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n  // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n  // access_token C2: Take the left- most half of the hash and base64url- encode it.\n  // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n  // is present in the ID Token.\n\n\n  validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {\n    this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n    let sha = 'SHA-256';\n\n    if (idTokenAlg.includes('384')) {\n      sha = 'SHA-384';\n    } else if (idTokenAlg.includes('512')) {\n      sha = 'SHA-512';\n    }\n\n    return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap(hash => {\n      this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);\n\n      if (hash === atHash) {\n        return of(true); // isValid;\n      } else {\n        return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map(newHash => {\n          this.loggerService.logDebug(configuration, '-gen access--' + hash);\n          return newHash === atHash;\n        }));\n      }\n    }));\n  }\n\n  millisToMinutesAndSeconds(millis) {\n    const minutes = Math.floor(millis / 60000);\n    const seconds = (millis % 60000 / 1000).toFixed(0);\n    return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n  }\n\n  calculateNowWithOffset(offsetSeconds) {\n    return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n  }\n\n}\n\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\nTokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n  return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JwkExtractor), i0.ɵɵinject(JwkWindowCryptoService), i0.ɵɵinject(JwtWindowCryptoService), i0.ɵɵinject(DOCUMENT));\n};\n\nTokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenValidationService,\n  factory: TokenValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: JwkExtractor\n    }, {\n      type: JwkWindowCryptoService\n    }, {\n      type: JwtWindowCryptoService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\n\nclass AuthStateService {\n  constructor(storagePersistenceService, loggerService, publicEventsService, tokenValidationService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.tokenValidationService = tokenValidationService;\n    this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n  }\n\n  get authenticated$() {\n    return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n  }\n\n  setAuthenticatedAndFireEvent(allConfigs) {\n    const result = this.composeAuthenticatedResult(allConfigs);\n    this.authenticatedInternal$.next(result);\n  }\n\n  setUnauthenticatedAndFireEvent(currentConfig, allConfigs) {\n    this.storagePersistenceService.resetAuthStateInStorage(currentConfig);\n    const result = this.composeUnAuthenticatedResult(allConfigs);\n    this.authenticatedInternal$.next(result);\n  }\n\n  updateAndPublishAuthState(authenticationResult) {\n    this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n  }\n\n  setAuthorizationData(accessToken, authResult, currentConfig, allConfigs) {\n    this.loggerService.logDebug(currentConfig, `storing the accessToken '${accessToken}'`);\n    this.storagePersistenceService.write('authzData', accessToken, currentConfig);\n    this.persistAccessTokenExpirationTime(authResult, currentConfig);\n    this.setAuthenticatedAndFireEvent(allConfigs);\n  }\n\n  getAccessToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getAccessToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getIdToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getIdToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getRefreshToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getRefreshToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getAuthenticationResult(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    return this.storagePersistenceService.getAuthenticationResult(configuration);\n  }\n\n  areAuthStorageTokensValid(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return false;\n    }\n\n    if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configuration)) {\n      this.loggerService.logDebug(configuration, 'persisted idToken is expired');\n      return false;\n    }\n\n    if (this.hasAccessTokenExpiredIfExpiryExists(configuration)) {\n      this.loggerService.logDebug(configuration, 'persisted accessToken is expired');\n      return false;\n    }\n\n    this.loggerService.logDebug(configuration, 'persisted idToken and accessToken are valid');\n    return true;\n  }\n\n  hasIdTokenExpiredAndRenewCheckIsEnabled(configuration) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds,\n      triggerRefreshWhenIdTokenExpired,\n      disableIdTokenValidation\n    } = configuration;\n\n    if (!triggerRefreshWhenIdTokenExpired || disableIdTokenValidation) {\n      return false;\n    }\n\n    const tokenToCheck = this.storagePersistenceService.getIdToken(configuration);\n    const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configuration, renewTimeBeforeTokenExpiresInSeconds);\n\n    if (idTokenExpired) {\n      this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n    }\n\n    return idTokenExpired;\n  }\n\n  hasAccessTokenExpiredIfExpiryExists(configuration) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds\n    } = configuration;\n    const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configuration);\n    const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configuration, renewTimeBeforeTokenExpiresInSeconds);\n    const hasExpired = !accessTokenHasNotExpired;\n\n    if (hasExpired) {\n      this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n    }\n\n    return hasExpired;\n  }\n\n  isAuthenticated(configuration) {\n    const hasAccessToken = !!this.storagePersistenceService.getAccessToken(configuration);\n    const hasIdToken = !!this.storagePersistenceService.getIdToken(configuration);\n    return hasAccessToken && hasIdToken;\n  }\n\n  decodeURIComponentSafely(token) {\n    if (token) {\n      return decodeURIComponent(token);\n    } else {\n      return '';\n    }\n  }\n\n  persistAccessTokenExpirationTime(authResult, configuration) {\n    if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\n      const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n      this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configuration);\n    }\n  }\n\n  composeAuthenticatedResult(allConfigs) {\n    if (allConfigs.length === 1) {\n      const {\n        configId\n      } = allConfigs[0];\n      return {\n        isAuthenticated: true,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: true\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n  }\n\n  composeUnAuthenticatedResult(allConfigs) {\n    if (allConfigs.length === 1) {\n      const {\n        configId\n      } = allConfigs[0];\n      return {\n        isAuthenticated: false,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: false\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n  }\n\n  checkAllConfigsIfTheyAreAuthenticated(allConfigs) {\n    const allConfigsAuthenticated = allConfigs.map(config => ({\n      configId: config.configId,\n      isAuthenticated: this.isAuthenticated(config)\n    }));\n    const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n    return {\n      allConfigsAuthenticated,\n      isAuthenticated\n    };\n  }\n\n}\n\nAuthStateService.ɵfac = function AuthStateService_Factory(t) {\n  return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(TokenValidationService));\n};\n\nAuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthStateService,\n  factory: AuthStateService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthStateService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: TokenValidationService\n    }];\n  }, null);\n})();\n\nclass IFrameService {\n  constructor(document, loggerService) {\n    this.document = document;\n    this.loggerService = loggerService;\n  }\n\n  getExistingIFrame(identifier) {\n    const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnParent)) {\n      return iFrameOnParent;\n    }\n\n    const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnSelf)) {\n      return iFrameOnSelf;\n    }\n\n    return null;\n  }\n\n  addIFrameToWindowBody(identifier, config) {\n    const sessionIframe = this.document.createElement('iframe');\n    sessionIframe.id = identifier;\n    sessionIframe.title = identifier;\n    this.loggerService.logDebug(config, sessionIframe);\n    sessionIframe.style.display = 'none';\n    this.document.body.appendChild(sessionIframe);\n    return sessionIframe;\n  }\n\n  getIFrameFromParentWindow(identifier) {\n    try {\n      const iFrameElement = this.document.defaultView.parent.document.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getIFrameFromWindow(identifier) {\n    const iFrameElement = this.document.getElementById(identifier);\n\n    if (this.isIFrameElement(iFrameElement)) {\n      return iFrameElement;\n    }\n\n    return null;\n  }\n\n  isIFrameElement(element) {\n    return !!element && element instanceof HTMLIFrameElement;\n  }\n\n}\n\nIFrameService.ɵfac = function IFrameService_Factory(t) {\n  return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nIFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IFrameService,\n  factory: IFrameService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IFrameService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nclass CheckSessionService {\n  constructor(storagePersistenceService, loggerService, iFrameService, eventService, zone, document) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.iFrameService = iFrameService;\n    this.eventService = eventService;\n    this.zone = zone;\n    this.document = document;\n    this.checkSessionReceived = false;\n    this.lastIFrameRefresh = 0;\n    this.outstandingMessages = 0;\n    this.heartBeatInterval = 3000;\n    this.iframeRefreshInterval = 60000;\n    this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n  }\n\n  get checkSessionChanged$() {\n    return this.checkSessionChangedInternal$.asObservable();\n  }\n\n  isCheckSessionConfigured(configuration) {\n    const {\n      startCheckSession\n    } = configuration;\n    return startCheckSession;\n  }\n\n  start(configuration) {\n    if (!!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    const {\n      clientId\n    } = configuration;\n    this.pollServerSession(clientId, configuration);\n  }\n\n  stop() {\n    if (!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    this.clearScheduledHeartBeat();\n    this.checkSessionReceived = false;\n  }\n\n  serverStateChanged(configuration) {\n    const {\n      startCheckSession\n    } = configuration;\n    return startCheckSession && this.checkSessionReceived;\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n  }\n\n  init(configuration) {\n    if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n      return of(undefined);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configuration, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n      return of();\n    }\n\n    const existingIframe = this.getOrCreateIframe(configuration);\n    const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n    if (checkSessionIframe) {\n      existingIframe.contentWindow.location.replace(checkSessionIframe);\n    } else {\n      this.loggerService.logWarning(configuration, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n    }\n\n    return new Observable(observer => {\n      existingIframe.onload = () => {\n        this.lastIFrameRefresh = Date.now();\n        observer.next();\n        observer.complete();\n      };\n    });\n  }\n\n  pollServerSession(clientId, configuration) {\n    this.outstandingMessages = 0;\n\n    const pollServerSessionRecur = () => {\n      this.init(configuration).pipe(take(1)).subscribe(() => {\n        var _a;\n\n        const existingIframe = this.getExistingIframe();\n\n        if (existingIframe && clientId) {\n          this.loggerService.logDebug(configuration, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          const sessionState = this.storagePersistenceService.read('session_state', configuration);\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n          if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\n            const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\n            this.outstandingMessages++;\n            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n          } else {\n            this.loggerService.logDebug(configuration, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n            this.checkSessionChangedInternal$.next(true);\n          }\n        } else {\n          this.loggerService.logWarning(configuration, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n        } // after sending three messages with no response, fail.\n\n\n        if (this.outstandingMessages > 3) {\n          this.loggerService.logError(configuration, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n        }\n\n        this.zone.runOutsideAngular(() => {\n          this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n        });\n      });\n    };\n\n    pollServerSessionRecur();\n  }\n\n  clearScheduledHeartBeat() {\n    clearTimeout(this.scheduledHeartBeatRunning);\n    this.scheduledHeartBeatRunning = null;\n  }\n\n  messageHandler(configuration, e) {\n    var _a;\n\n    const existingIFrame = this.getExistingIframe();\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\n    this.outstandingMessages = 0;\n\n    if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n      if (e.data === 'error') {\n        this.loggerService.logWarning(configuration, 'CheckSession - error from check session messageHandler');\n      } else if (e.data === 'changed') {\n        this.loggerService.logDebug(configuration, `CheckSession - ${e} from check session messageHandler`);\n        this.checkSessionReceived = true;\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.checkSessionChangedInternal$.next(true);\n      } else {\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.loggerService.logDebug(configuration, `CheckSession - ${e.data} from check session messageHandler`);\n      }\n    }\n  }\n\n  bindMessageEventToIframe(configuration) {\n    const iframeMessageEvent = this.messageHandler.bind(this, configuration);\n    this.document.defaultView.addEventListener('message', iframeMessageEvent, false);\n  }\n\n  getOrCreateIframe(configuration) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configuration);\n      this.bindMessageEventToIframe(configuration);\n      return frame;\n    }\n\n    return existingIframe;\n  }\n\n}\n\nCheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n  return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n};\n\nCheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckSessionService,\n  factory: CheckSessionService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckSessionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: IFrameService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: i0.NgZone\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass CurrentUrlService {\n  constructor(document) {\n    this.document = document;\n  }\n\n  getStateParamFromCurrentUrl(url) {\n    const currentUrl = url || this.getCurrentUrl();\n    const parsedUrl = new URL(currentUrl);\n    const urlParams = new URLSearchParams(parsedUrl.search);\n    const stateFromUrl = urlParams.get('state');\n    return stateFromUrl;\n  }\n\n  getCurrentUrl() {\n    return this.document.defaultView.location.toString();\n  }\n\n}\n\nCurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n  return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CurrentUrlService,\n  factory: CurrentUrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CurrentUrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[\"NotSet\"] = \"NotSet\";\n  ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n  ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n  ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n  ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n  ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n  ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n  ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n  ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n  ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n  ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n  ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n  ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n  ValidationResult[\"Ok\"] = \"Ok\";\n  ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n  ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n})(ValidationResult || (ValidationResult = {}));\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nclass RandomService {\n  constructor(cryptoService, loggerService) {\n    this.cryptoService = cryptoService;\n    this.loggerService = loggerService;\n  }\n\n  createRandom(requiredLength, configuration) {\n    if (requiredLength <= 0) {\n      return '';\n    }\n\n    if (requiredLength > 0 && requiredLength < 7) {\n      this.loggerService.logWarning(configuration, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n      requiredLength = 10;\n    }\n\n    const length = requiredLength - 6;\n    const arr = new Uint8Array(Math.floor(length / 2));\n    const crypto = this.cryptoService.getCrypto();\n\n    if (crypto) {\n      crypto.getRandomValues(arr);\n    }\n\n    return Array.from(arr, this.toHex).join('') + this.randomString(7);\n  }\n\n  toHex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n  }\n\n  randomString(length) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = new Uint32Array(length);\n    const crypto = this.cryptoService.getCrypto();\n\n    if (crypto) {\n      crypto.getRandomValues(values);\n\n      for (let i = 0; i < length; i++) {\n        result += characters[values[i] % characters.length];\n      }\n    }\n\n    return result;\n  }\n\n}\n\nRandomService.ɵfac = function RandomService_Factory(t) {\n  return new (t || RandomService)(i0.ɵɵinject(CryptoService), i0.ɵɵinject(LoggerService));\n};\n\nRandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RandomService,\n  factory: RandomService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RandomService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowsDataService {\n  constructor(storagePersistenceService, randomService, loggerService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.randomService = randomService;\n    this.loggerService = loggerService;\n  }\n\n  createNonce(configuration) {\n    const nonce = this.randomService.createRandom(40, configuration);\n    this.loggerService.logDebug(configuration, 'Nonce created. nonce:' + nonce);\n    this.setNonce(nonce, configuration);\n    return nonce;\n  }\n\n  setNonce(nonce, configuration) {\n    this.storagePersistenceService.write('authNonce', nonce, configuration);\n  }\n\n  getAuthStateControl(configuration) {\n    return this.storagePersistenceService.read('authStateControl', configuration);\n  }\n\n  setAuthStateControl(authStateControl, configuration) {\n    return this.storagePersistenceService.write('authStateControl', authStateControl, configuration);\n  }\n\n  getExistingOrCreateAuthStateControl(configuration) {\n    let state = this.storagePersistenceService.read('authStateControl', configuration);\n\n    if (!state) {\n      state = this.randomService.createRandom(40, configuration);\n      this.storagePersistenceService.write('authStateControl', state, configuration);\n    }\n\n    return state;\n  }\n\n  setSessionState(sessionState, configuration) {\n    this.storagePersistenceService.write('session_state', sessionState, configuration);\n  }\n\n  resetStorageFlowData(configuration) {\n    this.storagePersistenceService.resetStorageFlowData(configuration);\n  }\n\n  getCodeVerifier(configuration) {\n    return this.storagePersistenceService.read('codeVerifier', configuration);\n  }\n\n  createCodeVerifier(configuration) {\n    const codeVerifier = this.randomService.createRandom(67, configuration);\n    this.storagePersistenceService.write('codeVerifier', codeVerifier, configuration);\n    return codeVerifier;\n  }\n\n  isCodeFlowInProgress(configuration) {\n    const storageObject = this.getCodeFlowInProgressStorageEntry(configuration);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    return storageObject.state === 'in progress';\n  }\n\n  setCodeFlowInProgress(configuration) {\n    const storageObject = {\n      state: 'in progress'\n    };\n    this.storagePersistenceService.write('storageCodeFlowInProgress', JSON.stringify(storageObject), configuration);\n  }\n\n  resetCodeFlowInProgress(configuration) {\n    this.storagePersistenceService.write('storageCodeFlowInProgress', '', configuration);\n  }\n\n  getCodeFlowInProgressStorageEntry(configuration) {\n    const storageEntry = this.storagePersistenceService.read('storageCodeFlowInProgress', configuration);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n  isSilentRenewRunning(configuration) {\n    const {\n      configId,\n      silentRenewTimeoutInSeconds\n    } = configuration;\n    const storageObject = this.getSilentRenewRunningStorageEntry(configuration);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n    const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n    const currentDateUtc = Date.parse(new Date().toISOString());\n    const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n    const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n    if (isProbablyStuck) {\n      this.loggerService.logDebug(configuration, 'silent renew process is probably stuck, state will be reset.', configId);\n      this.resetSilentRenewRunning(configuration);\n      return false;\n    }\n\n    return storageObject.state === 'running';\n  }\n\n  setSilentRenewRunning(configuration) {\n    const storageObject = {\n      state: 'running',\n      dateOfLaunchedProcessUtc: new Date().toISOString()\n    };\n    this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configuration);\n  }\n\n  resetSilentRenewRunning(configuration) {\n    this.storagePersistenceService.write('storageSilentRenewRunning', '', configuration);\n  }\n\n  getSilentRenewRunningStorageEntry(configuration) {\n    const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configuration);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n}\n\nFlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n  return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(LoggerService));\n};\n\nFlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsDataService,\n  factory: FlowsDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: RandomService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowHelper {\n  isCurrentFlowCodeFlow(configuration) {\n    return this.currentFlowIs('code', configuration);\n  }\n\n  isCurrentFlowAnyImplicitFlow(configuration) {\n    return this.isCurrentFlowImplicitFlowWithAccessToken(configuration) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configuration);\n  }\n\n  isCurrentFlowCodeFlowWithRefreshTokens(configuration) {\n    const {\n      useRefreshToken\n    } = configuration;\n\n    if (this.isCurrentFlowCodeFlow(configuration) && useRefreshToken) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isCurrentFlowImplicitFlowWithAccessToken(configuration) {\n    return this.currentFlowIs('id_token token', configuration);\n  }\n\n  currentFlowIs(flowTypes, configuration) {\n    const {\n      responseType\n    } = configuration;\n\n    if (Array.isArray(flowTypes)) {\n      return flowTypes.some(x => responseType === x);\n    }\n\n    return responseType === flowTypes;\n  }\n\n  isCurrentFlowImplicitFlowWithoutAccessToken(configuration) {\n    return this.currentFlowIs('id_token', configuration);\n  }\n\n}\n\nFlowHelper.ɵfac = function FlowHelper_Factory(t) {\n  return new (t || FlowHelper)();\n};\n\nFlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowHelper,\n  factory: FlowHelper.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowHelper, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\nconst AUTH0_ENDPOINT = 'auth0.com';\n\nclass UrlService {\n  constructor(loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.flowHelper = flowHelper;\n    this.storagePersistenceService = storagePersistenceService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n  }\n\n  getUrlParameter(urlToCheck, name) {\n    if (!urlToCheck) {\n      return '';\n    }\n\n    if (!name) {\n      return '';\n    }\n\n    name = name.replace(/[[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&#]' + name + '=([^&#]*)');\n    const results = regex.exec(urlToCheck);\n    return results === null ? '' : decodeURIComponent(results[1]);\n  }\n\n  isCallbackFromSts(currentUrl) {\n    return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n  }\n\n  getRefreshSessionSilentRenewUrl(config, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      return this.createUrlCodeFlowWithSilentRenew(config, customParams);\n    }\n\n    return of(this.createUrlImplicitFlowWithSilentRenew(config, customParams) || '');\n  }\n\n  getAuthorizeParUrl(requestUri, configuration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('request_uri', requestUri);\n    params = params.append('client_id', clientId);\n    return `${authorizationUrl}?${params}`;\n  }\n\n  getAuthorizeUrl(config, authOptions) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      return this.createUrlCodeFlowAuthorize(config, authOptions);\n    }\n\n    return of(this.createUrlImplicitFlowAuthorize(config, authOptions) || '');\n  }\n\n  getEndSessionEndpoint(configuration) {\n    var _a;\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\n\n    if (!endSessionEndpoint) {\n      return {\n        url: '',\n        existingParams: ''\n      };\n    }\n\n    const urlParts = endSessionEndpoint.split('?');\n    const url = urlParts[0];\n    const existingParams = (_a = urlParts[1]) !== null && _a !== void 0 ? _a : '';\n    return {\n      url,\n      existingParams\n    };\n  }\n\n  getEndSessionUrl(configuration, customParams) {\n    const idToken = this.storagePersistenceService.getIdToken(configuration);\n    const {\n      customParamsEndSessionRequest\n    } = configuration;\n    const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\n    return this.createEndSessionUrl(idToken, configuration, mergedParams);\n  }\n\n  createRevocationEndpointBodyAccessToken(token, configuration) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'access_token');\n    return params.toString();\n  }\n\n  createRevocationEndpointBodyRefreshToken(token, configuration) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'refresh_token');\n    return params.toString();\n  }\n\n  getRevocationEndpointUrl(configuration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\n\n    if (!revocationEndpoint) {\n      return null;\n    }\n\n    const urlParts = revocationEndpoint.split('?');\n    const revocationEndpointUrl = urlParts[0];\n    return revocationEndpointUrl;\n  }\n\n  createBodyForCodeFlowCodeRequest(code, configuration, customTokenParams) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'authorization_code');\n    params = params.set('client_id', clientId);\n\n    if (!configuration.disablePkce) {\n      const codeVerifier = this.flowsDataService.getCodeVerifier(configuration);\n\n      if (!codeVerifier) {\n        this.loggerService.logError(configuration, `CodeVerifier is not set `, codeVerifier);\n        return null;\n      }\n\n      params = params.set('code_verifier', codeVerifier);\n    }\n\n    params = params.set('code', code);\n\n    if (customTokenParams) {\n      params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\n    }\n\n    const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n    if (this.flowsDataService.isSilentRenewRunning(configuration) && silentRenewUrl) {\n      params = params.set('redirect_uri', silentRenewUrl);\n      return params.toString();\n    }\n\n    const redirectUrl = this.getRedirectUrl(configuration);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    params = params.set('redirect_uri', redirectUrl);\n    return params.toString();\n  }\n\n  createBodyForCodeFlowRefreshTokensRequest(refreshToken, configuration, customParamsRefresh) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'refresh_token');\n    params = params.set('client_id', clientId);\n    params = params.set('refresh_token', refreshToken);\n\n    if (customParamsRefresh) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\n    }\n\n    return params.toString();\n  }\n\n  createBodyForParCodeFlowRequest(configuration, customParamsRequest) {\n    const redirectUrl = this.getRedirectUrl(configuration);\n\n    if (!redirectUrl) {\n      return of(null);\n    }\n\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const {\n        clientId,\n        responseType,\n        scope,\n        hdParam,\n        customParamsAuthRequest\n      } = configuration;\n      let params = this.createHttpParams('');\n      params = params.set('client_id', clientId);\n      params = params.append('redirect_uri', redirectUrl);\n      params = params.append('response_type', responseType);\n      params = params.append('scope', scope);\n      params = params.append('nonce', nonce);\n      params = params.append('state', state);\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n\n      if (hdParam) {\n        params = params.append('hd', hdParam);\n      }\n\n      if (customParamsAuthRequest) {\n        params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\n      }\n\n      if (customParamsRequest) {\n        params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\n      }\n\n      return params.toString();\n    }));\n  }\n\n  getPostLogoutRedirectUrl(configuration) {\n    const {\n      postLogoutRedirectUri\n    } = configuration;\n\n    if (!postLogoutRedirectUri) {\n      this.loggerService.logError(configuration, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n      return null;\n    }\n\n    return postLogoutRedirectUri;\n  }\n\n  createEndSessionUrl(idTokenHint, configuration, customParamsEndSession) {\n    // Auth0 needs a special logout url\n    // See https://auth0.com/docs/api/authentication#logout\n    if (this.isAuth0Endpoint(configuration)) {\n      return this.composeAuth0Endpoint(configuration);\n    }\n\n    const {\n      url,\n      existingParams\n    } = this.getEndSessionEndpoint(configuration);\n\n    if (!url) {\n      return null;\n    }\n\n    let params = this.createHttpParams(existingParams);\n\n    if (!!idTokenHint) {\n      params = params.set('id_token_hint', idTokenHint);\n    }\n\n    const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configuration);\n\n    if (postLogoutRedirectUri) {\n      params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (customParamsEndSession) {\n      params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\n    }\n\n    return `${url}?${params}`;\n  }\n\n  createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configuration, prompt, customRequestParams) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    if (!responseType) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n      return null;\n    }\n\n    if (!scope) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add scope because it was: `, scope);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configuration) && codeChallenge !== null) {\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n    }\n\n    const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\n\n    if (Object.keys(mergedParams).length > 0) {\n      params = this.appendCustomParams(Object.assign({}, mergedParams), params);\n    }\n\n    if (prompt) {\n      params = this.overWriteParam(params, 'prompt', prompt);\n    }\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    return `${authorizationUrl}?${params}`;\n  }\n\n  createUrlImplicitFlowWithSilentRenew(configuration, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ', state);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configuration, 'none', customParams);\n    }\n\n    this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowWithSilentRenew(configuration, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n      if (!silentRenewUrl) {\n        return '';\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (authWellKnownEndPoints) {\n        return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configuration, 'none', customParams);\n      }\n\n      this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }));\n  }\n\n  createUrlImplicitFlowAuthorize(configuration, authOptions) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configuration, authOptions);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (authWellKnownEndPoints) {\n      const {\n        customParams\n      } = authOptions || {};\n      return this.createAuthorizeUrl('', redirectUrl, nonce, state, configuration, null, customParams);\n    }\n\n    this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowAuthorize(config, authOptions) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n    const nonce = this.flowsDataService.createNonce(config);\n    this.loggerService.logDebug(config, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(config, authOptions);\n\n    if (!redirectUrl) {\n      return of(null);\n    }\n\n    return this.getCodeChallenge(config).pipe(map(codeChallenge => {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n      if (authWellKnownEndPoints) {\n        const {\n          customParams\n        } = authOptions || {};\n        return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, config, null, customParams);\n      }\n\n      this.loggerService.logError(config, 'authWellKnownEndpoints is undefined');\n      return '';\n    }));\n  }\n\n  getCodeChallenge(config) {\n    if (config.disablePkce) {\n      return of(null);\n    } // code_challenge with \"S256\"\n\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(config);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier);\n  }\n\n  getRedirectUrl(configuration, authOptions) {\n    let {\n      redirectUrl\n    } = configuration;\n\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.redirectUrl) {\n      // override by redirectUrl from authOptions\n      redirectUrl = authOptions.redirectUrl;\n    }\n\n    if (!redirectUrl) {\n      this.loggerService.logError(configuration, `could not get redirectUrl, was: `, redirectUrl);\n      return null;\n    }\n\n    return redirectUrl;\n  }\n\n  getSilentRenewUrl(configuration) {\n    const {\n      silentRenewUrl\n    } = configuration;\n\n    if (!silentRenewUrl) {\n      this.loggerService.logError(configuration, `could not get silentRenewUrl, was: `, silentRenewUrl);\n      return null;\n    }\n\n    return silentRenewUrl;\n  }\n\n  getClientId(configuration) {\n    const {\n      clientId\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `could not get clientId, was: `, clientId);\n      return null;\n    }\n\n    return clientId;\n  }\n\n  appendCustomParams(customParams, params) {\n    for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\n      params = params.append(key, value.toString());\n    }\n\n    return params;\n  }\n\n  overWriteParam(params, key, value) {\n    return params.set(key, value);\n  }\n\n  createHttpParams(existingParams) {\n    existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\n    const params = new HttpParams({\n      fromString: existingParams,\n      encoder: new UriEncoder()\n    });\n    return params;\n  }\n\n  isAuth0Endpoint(configuration) {\n    const {\n      authority\n    } = configuration;\n\n    if (!authority) {\n      return false;\n    }\n\n    return authority.endsWith(AUTH0_ENDPOINT);\n  }\n\n  composeAuth0Endpoint(configuration) {\n    // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\n    const {\n      authority,\n      clientId\n    } = configuration;\n    const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configuration);\n    return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\n  }\n\n}\n\nUrlService.ɵfac = function UrlService_Factory(t) {\n  return new (t || UrlService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JwtWindowCryptoService));\n};\n\nUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlService,\n  factory: UrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: JwtWindowCryptoService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackHandlerService {\n  constructor(urlService, loggerService, tokenValidationService, flowsDataService, storagePersistenceService, dataService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.tokenValidationService = tokenValidationService;\n    this.flowsDataService = flowsDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.dataService = dataService;\n  } // STEP 1 Code Flow\n\n\n  codeFlowCallback(urlToCheck, config) {\n    const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n    const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n    const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\n\n    if (!state) {\n      this.loggerService.logDebug(config, 'no state in url');\n      return throwError(() => new Error('no state in url'));\n    }\n\n    if (!code) {\n      this.loggerService.logDebug(config, 'no code in url');\n      return throwError(() => new Error('no code in url'));\n    }\n\n    this.loggerService.logDebug(config, 'running validation for callback', urlToCheck);\n    const initialCallbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: false,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(initialCallbackContext);\n  } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n  codeFlowCodeRequest(callbackContext, config) {\n    const authStateControl = this.flowsDataService.getAuthStateControl(config);\n    const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, config);\n\n    if (!isStateCorrect) {\n      return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\n    }\n\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, config, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\n    return this.dataService.post(tokenEndpoint, bodyForCodeFlow, config, headers).pipe(switchMap(response => {\n      let authResult = Object.assign(Object.assign({}, response), {\n        state: callbackContext.state,\n        session_state: callbackContext.sessionState\n      });\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n      const {\n        authority\n      } = config;\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(config, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, config) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = config;\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(config, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => error);\n    }));\n  }\n\n}\n\nCodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n  return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n};\n\nCodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackHandlerService,\n  factory: CodeFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\n\nclass UserService {\n  constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper) {\n    this.oidcDataService = oidcDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.eventService = eventService;\n    this.loggerService = loggerService;\n    this.tokenHelperService = tokenHelperService;\n    this.flowHelper = flowHelper;\n    this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n  }\n\n  get userData$() {\n    return this.userDataInternal$.asObservable();\n  }\n\n  getAndPersistUserDataInStore(currentConfiguration, allConfigs, isRenewProcess = false, idToken, decodedIdToken) {\n    idToken = idToken || this.storagePersistenceService.getIdToken(currentConfiguration);\n    decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, currentConfiguration);\n    const existingUserDataFromStorage = this.getUserDataFromStore(currentConfiguration);\n    const haveUserData = !!existingUserDataFromStorage;\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(currentConfiguration);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(currentConfiguration);\n    const accessToken = this.storagePersistenceService.getAccessToken(currentConfiguration);\n\n    if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n      this.loggerService.logDebug(currentConfiguration, `authCallback idToken flow with accessToken ${accessToken}`);\n      this.setUserDataToStore(decodedIdToken, currentConfiguration, allConfigs);\n      return of(decodedIdToken);\n    }\n\n    const {\n      renewUserInfoAfterTokenRenew\n    } = currentConfiguration;\n\n    if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n      return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, currentConfiguration, allConfigs).pipe(switchMap(userData => {\n        this.loggerService.logDebug(currentConfiguration, 'Received user data: ', userData);\n\n        if (!!userData) {\n          this.loggerService.logDebug(currentConfiguration, 'accessToken: ', accessToken);\n          return of(userData);\n        } else {\n          return throwError(() => new Error('Received no user data, request failed'));\n        }\n      }));\n    }\n\n    return of(existingUserDataFromStorage);\n  }\n\n  getUserDataFromStore(currentConfiguration) {\n    return this.storagePersistenceService.read('userData', currentConfiguration) || null;\n  }\n\n  publishUserDataIfExists(currentConfiguration, allConfigs) {\n    const userData = this.getUserDataFromStore(currentConfiguration);\n\n    if (userData) {\n      this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n    }\n  }\n\n  setUserDataToStore(userData, currentConfiguration, allConfigs) {\n    this.storagePersistenceService.write('userData', userData, currentConfiguration);\n    this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n  }\n\n  resetUserDataInStore(currentConfiguration, allConfigs) {\n    this.storagePersistenceService.remove('userData', currentConfiguration);\n    this.fireUserDataEvent(currentConfiguration, allConfigs, null);\n  }\n\n  getUserDataOidcFlowAndSave(idTokenSub, currentConfiguration, allConfigs) {\n    return this.getIdentityUserData(currentConfiguration).pipe(map(data => {\n      if (this.validateUserDataSubIdToken(currentConfiguration, idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\n        this.setUserDataToStore(data, currentConfiguration, allConfigs);\n        return data;\n      } else {\n        // something went wrong, user data sub does not match that from id_token\n        this.loggerService.logWarning(currentConfiguration, `User data sub does not match sub in id_token, resetting`);\n        this.resetUserDataInStore(currentConfiguration, allConfigs);\n        return null;\n      }\n    }));\n  }\n\n  getIdentityUserData(currentConfiguration) {\n    const token = this.storagePersistenceService.getAccessToken(currentConfiguration);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(currentConfiguration, 'init check session: authWellKnownEndpoints is undefined');\n      return throwError(() => new Error('authWellKnownEndpoints is undefined'));\n    }\n\n    const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      this.loggerService.logError(currentConfiguration, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n      return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\n    }\n\n    return this.oidcDataService.get(userInfoEndpoint, currentConfiguration, token).pipe(retry(2));\n  }\n\n  validateUserDataSubIdToken(currentConfiguration, idTokenSub, userDataSub) {\n    if (!idTokenSub) {\n      return false;\n    }\n\n    if (!userDataSub) {\n      return false;\n    }\n\n    if (idTokenSub !== userDataSub) {\n      this.loggerService.logDebug(currentConfiguration, 'validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n      return false;\n    }\n\n    return true;\n  }\n\n  fireUserDataEvent(currentConfiguration, allConfigs, passedUserData) {\n    const userData = this.composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData);\n    this.userDataInternal$.next(userData);\n    const {\n      configId\n    } = currentConfiguration;\n    this.eventService.fireEvent(EventTypes.UserDataChanged, {\n      configId,\n      userData: passedUserData\n    });\n  }\n\n  composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData) {\n    const hasManyConfigs = allConfigs.length > 1;\n\n    if (!hasManyConfigs) {\n      const {\n        configId\n      } = currentConfiguration;\n      return this.composeSingleUserDataResult(configId, passedUserData);\n    }\n\n    const allUserData = allConfigs.map(config => {\n      const {\n        configId\n      } = currentConfiguration;\n\n      if (this.currentConfigIsToUpdate(configId, config)) {\n        return {\n          configId: config.configId,\n          userData: passedUserData\n        };\n      }\n\n      const alreadySavedUserData = this.storagePersistenceService.read('userData', config) || null;\n      return {\n        configId: config.configId,\n        userData: alreadySavedUserData\n      };\n    });\n    return {\n      userData: null,\n      allUserData\n    };\n  }\n\n  composeSingleUserDataResult(configId, userData) {\n    return {\n      userData,\n      allUserData: [{\n        configId,\n        userData\n      }]\n    };\n  }\n\n  currentConfigIsToUpdate(configId, config) {\n    return config.configId === configId;\n  }\n\n}\n\nUserService.ɵfac = function UserService_Factory(t) {\n  return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper));\n};\n\nUserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserService,\n  factory: UserService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass ResetAuthDataService {\n  constructor(authStateService, flowsDataService, userService, loggerService) {\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n  }\n\n  resetAuthorizationData(currentConfiguration, allConfigs) {\n    this.userService.resetUserDataInStore(currentConfiguration, allConfigs);\n    this.flowsDataService.resetStorageFlowData(currentConfiguration);\n    this.authStateService.setUnauthenticatedAndFireEvent(currentConfiguration, allConfigs);\n    this.loggerService.logDebug(currentConfiguration, 'Local Login information cleaned up and event fired');\n  }\n\n}\n\nResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n  return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService));\n};\n\nResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResetAuthDataService,\n  factory: ResetAuthDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResetAuthDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackHandlerService {\n  constructor(resetAuthDataService, loggerService, flowsDataService, document) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.document = document;\n  } // STEP 1 Code Flow\n  // STEP 1 Implicit Flow\n\n\n  implicitFlowCallback(config, allConfigs, hash) {\n    const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(config);\n    this.loggerService.logDebug(config, 'BEGIN callback, no auth data');\n\n    if (!isRenewProcessData) {\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n    }\n\n    hash = hash || this.document.location.hash.substring(1);\n    const authResult = hash.split('&').reduce((resultData, item) => {\n      const parts = item.split('=');\n      resultData[parts.shift()] = parts.join('=');\n      return resultData;\n    }, {});\n    const callbackContext = {\n      code: null,\n      refreshToken: null,\n      state: null,\n      sessionState: null,\n      authResult,\n      isRenewProcess: isRenewProcessData,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(callbackContext);\n  }\n\n}\n\nImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n  return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackHandlerService,\n  factory: ImplicitFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass SigninKeyDataService {\n  constructor(storagePersistenceService, loggerService, dataService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n  }\n\n  getSigningKeys(currentConfiguration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n    const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\n\n    if (!jwksUri) {\n      const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n      this.loggerService.logWarning(currentConfiguration, error);\n      return throwError(() => new Error(error));\n    }\n\n    this.loggerService.logDebug(currentConfiguration, 'Getting signinkeys from ', jwksUri);\n    return this.dataService.get(jwksUri, currentConfiguration).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, currentConfiguration)));\n  }\n\n  handleErrorGetSigningKeys(errorResponse, currentConfiguration) {\n    let errMsg = '';\n\n    if (errorResponse instanceof HttpResponse) {\n      const body = errorResponse.body || {};\n      const err = JSON.stringify(body);\n      const {\n        status,\n        statusText\n      } = errorResponse;\n      errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n    } else {\n      const {\n        message\n      } = errorResponse;\n      errMsg = !!message ? message : `${errorResponse}`;\n    }\n\n    this.loggerService.logError(currentConfiguration, errMsg);\n    return throwError(() => new Error(errMsg));\n  }\n\n}\n\nSigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n  return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n};\n\nSigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SigninKeyDataService,\n  factory: SigninKeyDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SigninKeyDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst JWT_KEYS = 'jwtKeys';\n\nclass HistoryJwtKeysCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService, document) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.signInKeyDataService = signInKeyDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.document = document;\n  } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n  callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs) {\n    if (!this.responseHasIdToken(callbackContext)) {\n      const existingIdToken = this.storagePersistenceService.getIdToken(config);\n      callbackContext.authResult = Object.assign(Object.assign({}, callbackContext.authResult), {\n        id_token: existingIdToken\n      });\n    }\n\n    this.storagePersistenceService.write('authnResult', callbackContext.authResult, config);\n\n    if (config.allowUnsafeReuseRefreshToken && callbackContext.authResult.refresh_token) {\n      this.storagePersistenceService.write('reusable_refresh_token', callbackContext.authResult.refresh_token, config);\n    }\n\n    if (this.historyCleanUpTurnedOn(config) && !callbackContext.isRenewProcess) {\n      this.resetBrowserHistory();\n    } else {\n      this.loggerService.logDebug(config, 'history clean up inactive');\n    }\n\n    if (callbackContext.authResult.error) {\n      const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n      this.loggerService.logDebug(config, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      this.flowsDataService.setNonce('', config);\n      this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(config, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n    return this.signInKeyDataService.getSigningKeys(config).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, config)), catchError(err => {\n      // fallback: try to load jwtKeys from storage\n      const storedJwtKeys = this.readSigningKeys(config);\n\n      if (!!storedJwtKeys) {\n        this.loggerService.logWarning(config, `Failed to retrieve signing keys, fallback to stored keys`);\n        return of(storedJwtKeys);\n      }\n\n      return throwError(() => new Error(err));\n    }), switchMap(jwtKeys => {\n      if (jwtKeys) {\n        callbackContext.jwtKeys = jwtKeys;\n        return of(callbackContext);\n      }\n\n      const errorMessage = `Failed to retrieve signing key`;\n      this.loggerService.logWarning(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n      this.loggerService.logWarning(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  responseHasIdToken(callbackContext) {\n    var _a;\n\n    return !!((_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token);\n  }\n\n  handleResultErrorFromCallback(result, isRenewProcess) {\n    let validationResult = ValidationResult.SecureTokenServerError;\n\n    if (result.error === 'login_required') {\n      validationResult = ValidationResult.LoginRequired;\n    }\n\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult,\n      isRenewProcess\n    });\n  }\n\n  historyCleanUpTurnedOn(config) {\n    const {\n      historyCleanupOff\n    } = config;\n    return !historyCleanupOff;\n  }\n\n  resetBrowserHistory() {\n    this.document.defaultView.history.replaceState({}, this.document.title, this.document.defaultView.location.origin + this.document.defaultView.location.pathname);\n  }\n\n  storeSigningKeys(jwtKeys, config) {\n    this.storagePersistenceService.write(JWT_KEYS, jwtKeys, config);\n  }\n\n  readSigningKeys(config) {\n    return this.storagePersistenceService.read(JWT_KEYS, config);\n  }\n\n}\n\nHistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n  return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nHistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HistoryJwtKeysCallbackHandlerService,\n  factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryJwtKeysCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: SigninKeyDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass UserCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService, userService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 5 userData\n\n\n  callbackUser(callbackContext, configuration, allConfigs) {\n    const {\n      isRenewProcess,\n      validationResult,\n      authResult,\n      refreshToken\n    } = callbackContext;\n    const {\n      autoUserInfo,\n      renewUserInfoAfterTokenRenew\n    } = configuration;\n\n    if (!autoUserInfo) {\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n        // userData is set to the id_token decoded, auto get user data set to false\n        if (validationResult.decodedIdToken) {\n          this.userService.setUserDataToStore(validationResult.decodedIdToken, configuration, allConfigs);\n        }\n      }\n\n      if (!isRenewProcess && !refreshToken) {\n        this.flowsDataService.setSessionState(authResult.session_state, configuration);\n      }\n\n      this.publishAuthState(validationResult, isRenewProcess);\n      return of(callbackContext);\n    }\n\n    return this.userService.getAndPersistUserDataInStore(configuration, allConfigs, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n      if (!!userData) {\n        if (!refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configuration);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      } else {\n        this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n        this.publishUnauthenticatedState(validationResult, isRenewProcess);\n        const errorMessage = `Called for userData but they were ${userData}`;\n        this.loggerService.logWarning(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n      this.loggerService.logWarning(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  publishAuthState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: true,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n  publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nUserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n  return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nUserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserCallbackHandlerService,\n  factory: UserCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\n    at_hash: ''\n  }, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nclass EqualityService {\n  isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n    if (this.isNullOrUndefined(value1)) {\n      return false;\n    }\n\n    if (this.isNullOrUndefined(value2)) {\n      return false;\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      return false;\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    return this.arraysHaveEqualContent(value1, value2);\n  }\n\n  areEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysStrictEqual(value1, value2);\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreObjects(value1, value2)) {\n      return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      if (Array.isArray(value1) && this.valueIsString(value2)) {\n        return value1[0] === value2;\n      }\n\n      if (Array.isArray(value2) && this.valueIsString(value1)) {\n        return value2[0] === value1;\n      }\n    }\n\n    return value1 === value2;\n  }\n\n  oneValueIsStringAndTheOtherIsArray(value1, value2) {\n    return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n  }\n\n  bothValuesAreObjects(value1, value2) {\n    return this.valueIsObject(value1) && this.valueIsObject(value2);\n  }\n\n  bothValuesAreStrings(value1, value2) {\n    return this.valueIsString(value1) && this.valueIsString(value2);\n  }\n\n  bothValuesAreArrays(value1, value2) {\n    return Array.isArray(value1) && Array.isArray(value2);\n  }\n\n  valueIsString(value) {\n    return typeof value === 'string' || value instanceof String;\n  }\n\n  valueIsObject(value) {\n    return typeof value === 'object';\n  }\n\n  arraysStrictEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (let i = arr1.length; i--;) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  arraysHaveEqualContent(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.some(v => arr2.includes(v));\n  }\n\n  isNullOrUndefined(val) {\n    return val === null || val === undefined;\n  }\n\n}\n\nEqualityService.ɵfac = function EqualityService_Factory(t) {\n  return new (t || EqualityService)();\n};\n\nEqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EqualityService,\n  factory: EqualityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EqualityService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StateValidationService {\n  constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, equalityService, flowHelper) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.tokenValidationService = tokenValidationService;\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.equalityService = equalityService;\n    this.flowHelper = flowHelper;\n  }\n\n  getValidatedStateResult(callbackContext, configuration) {\n    if (!callbackContext || callbackContext.authResult.error) {\n      return of(new StateValidationResult('', '', false, {}));\n    }\n\n    return this.validateState(callbackContext, configuration);\n  }\n\n  validateState(callbackContext, configuration) {\n    const toReturn = new StateValidationResult();\n    const authStateControl = this.storagePersistenceService.read('authStateControl', configuration);\n\n    if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configuration)) {\n      this.loggerService.logWarning(configuration, 'authCallback incorrect state');\n      toReturn.state = ValidationResult.StatesDoNotMatch;\n      this.handleUnsuccessfulValidation(configuration);\n      return of(toReturn);\n    }\n\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configuration);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configuration);\n\n    if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n      toReturn.accessToken = callbackContext.authResult.access_token;\n    }\n\n    const disableIdTokenValidation = configuration.disableIdTokenValidation;\n\n    if (disableIdTokenValidation) {\n      toReturn.state = ValidationResult.Ok; // TODO TESTING\n\n      toReturn.authResponseIsValid = true;\n      return of(toReturn);\n    }\n\n    const isInRefreshTokenFlow = callbackContext.isRenewProcess && !!callbackContext.refreshToken;\n    const hasIdToken = !!callbackContext.authResult.id_token;\n\n    if (isInRefreshTokenFlow && !hasIdToken) {\n      toReturn.state = ValidationResult.Ok; // TODO TESTING\n\n      toReturn.authResponseIsValid = true;\n      return of(toReturn);\n    }\n\n    if (callbackContext.authResult.id_token) {\n      const {\n        clientId,\n        issValidationOff,\n        maxIdTokenIatOffsetAllowedInSeconds,\n        disableIatOffsetValidation,\n        ignoreNonceAfterRefresh,\n        renewTimeBeforeTokenExpiresInSeconds\n      } = configuration;\n      toReturn.idToken = callbackContext.authResult.id_token;\n      toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configuration);\n      return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configuration).pipe(mergeMap(isSignatureIdTokenValid => {\n        if (!isSignatureIdTokenValid) {\n          this.loggerService.logDebug(configuration, 'authCallback Signature validation failed id_token');\n          toReturn.state = ValidationResult.SignatureFailed;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        const authNonce = this.storagePersistenceService.read('authNonce', configuration);\n\n        if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\n          toReturn.state = ValidationResult.IncorrectNonce;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configuration)) {\n          this.loggerService.logDebug(configuration, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n          toReturn.state = ValidationResult.RequiredPropertyMissing;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!isInRefreshTokenFlow && !this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n          toReturn.state = ValidationResult.MaxOffsetExpired;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n        if (authWellKnownEndPoints) {\n          if (issValidationOff) {\n            this.loggerService.logDebug(configuration, 'iss validation is turned off, this is not recommended!');\n          } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n            toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n        } else {\n          this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n          toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect aud');\n          toReturn.state = ValidationResult.IncorrectAud;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n          this.loggerService.logWarning(configuration, 'authCallback missing azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback pre, post id_token claims do not match in refresh');\n          toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!isInRefreshTokenFlow && !this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configuration, renewTimeBeforeTokenExpiresInSeconds)) {\n          this.loggerService.logWarning(configuration, 'authCallback id token expired');\n          toReturn.state = ValidationResult.TokenExpired;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n      }));\n    } else {\n      this.loggerService.logDebug(configuration, 'No id_token found, skipping id_token validation');\n    }\n\n    return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n  }\n\n  validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext) {\n    // flow id_token\n    if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configuration);\n      this.handleUnsuccessfulValidation(configuration);\n      return of(toReturn);\n    } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n    if (callbackContext.authResult.id_token) {\n      const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configuration);\n\n      if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n        this.loggerService.logDebug(configuration, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n      } else {\n        return this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\n        configuration).pipe(map(valid => {\n          if (!valid || !toReturn.accessToken) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect at_hash');\n            toReturn.state = ValidationResult.IncorrectAtHash;\n            this.handleUnsuccessfulValidation(configuration);\n            return toReturn;\n          } else {\n            toReturn.authResponseIsValid = true;\n            toReturn.state = ValidationResult.Ok;\n            this.handleSuccessfulValidation(configuration);\n            return toReturn;\n          }\n        }));\n      }\n    }\n\n    toReturn.authResponseIsValid = true;\n    toReturn.state = ValidationResult.Ok;\n    this.handleSuccessfulValidation(configuration);\n    return of(toReturn);\n  }\n\n  isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configuration) {\n    const {\n      useRefreshToken,\n      disableRefreshIdTokenAuthTimeValidation\n    } = configuration;\n\n    if (!useRefreshToken) {\n      return true;\n    }\n\n    if (!callbackContext.existingIdToken) {\n      return true;\n    }\n\n    const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configuration); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n    // except that it might not contain an id_token.\n    // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n    // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n    if (decodedIdToken.iss !== newIdToken.iss) {\n      this.loggerService.logDebug(configuration, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n      return false;\n    } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n    //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n    // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n    if (decodedIdToken.azp !== newIdToken.azp) {\n      this.loggerService.logDebug(configuration, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n      return false;\n    } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (decodedIdToken.sub !== newIdToken.sub) {\n      this.loggerService.logDebug(configuration, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n      return false;\n    } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\n      this.loggerService.logDebug(configuration, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\n      return false;\n    }\n\n    if (disableRefreshIdTokenAuthTimeValidation) {\n      return true;\n    } // its iat Claim MUST represent the time that the new ID Token is issued,\n    // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n    // - not the time that the new ID token is issued,\n\n\n    if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n      this.loggerService.logDebug(configuration, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  handleSuccessfulValidation(configuration) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = configuration;\n    this.storagePersistenceService.write('authNonce', null, configuration);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configuration);\n    }\n\n    this.loggerService.logDebug(configuration, 'authCallback token(s) validated, continue');\n  }\n\n  handleUnsuccessfulValidation(configuration) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = configuration;\n    this.storagePersistenceService.write('authNonce', null, configuration);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configuration);\n    }\n\n    this.loggerService.logDebug(configuration, 'authCallback token(s) invalid');\n  }\n\n}\n\nStateValidationService.ɵfac = function StateValidationService_Factory(t) {\n  return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n};\n\nStateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationService,\n  factory: StateValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: EqualityService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass StateValidationCallbackHandlerService {\n  constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, document) {\n    this.loggerService = loggerService;\n    this.stateValidationService = stateValidationService;\n    this.authStateService = authStateService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.document = document;\n  } // STEP 4 All flows\n\n\n  callbackStateValidation(callbackContext, configuration, allConfigs) {\n    return this.stateValidationService.getValidatedStateResult(callbackContext, configuration).pipe(map(validationResult => {\n      callbackContext.validationResult = validationResult;\n\n      if (validationResult.authResponseIsValid) {\n        this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configuration, allConfigs);\n        return callbackContext;\n      } else {\n        const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.document.location.hash}`;\n        this.loggerService.logWarning(configuration, errorMessage);\n        this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n        this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n        throw new Error(errorMessage);\n      }\n    }));\n  }\n\n  publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nStateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n  return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nStateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationCallbackHandlerService,\n  factory: StateValidationCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: StateValidationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass RefreshSessionCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n  } // STEP 1 Refresh session\n\n\n  refreshSessionWithRefreshTokens(config) {\n    const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n    this.loggerService.logDebug(config, 'RefreshSession created. Adding myautostate: ' + stateData);\n    const refreshToken = this.authStateService.getRefreshToken(config);\n    const idToken = this.authStateService.getIdToken(config);\n\n    if (refreshToken) {\n      const callbackContext = {\n        code: null,\n        refreshToken,\n        state: stateData,\n        sessionState: null,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: idToken\n      };\n      this.loggerService.logDebug(config, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n      this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, config);\n      return of(callbackContext);\n    } else {\n      const errorMessage = 'no refresh token found, please login';\n      this.loggerService.logError(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n  }\n\n}\n\nRefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n  return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n};\n\nRefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionCallbackHandlerService,\n  factory: RefreshSessionCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass RefreshTokenCallbackHandlerService {\n  constructor(urlService, loggerService, dataService, storagePersistenceService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  } // STEP 2 Refresh Token\n\n\n  refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);\n    return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap(response => {\n      this.loggerService.logDebug(config, 'token refresh response: ', response);\n      response.state = callbackContext.state;\n      callbackContext.authResult = response;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n      const {\n        authority\n      } = config;\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(config, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, config) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = config;\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(config, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => error);\n    }));\n  }\n\n}\n\nRefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n  return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nRefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshTokenCallbackHandlerService,\n  factory: RefreshTokenCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshTokenCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass FlowsService {\n  constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n    this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n    this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n    this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n    this.userHandlerService = userHandlerService;\n    this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n    this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n    this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n  }\n\n  processCodeFlowCallback(urlToCheck, config, allConfigs) {\n    return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, config).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, config)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processSilentRenewCodeFlowCallback(firstContext, config, allConfigs) {\n    return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, config).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processImplicitFlowCallback(config, allConfigs, hash) {\n    return this.implicitFlowCallbackHandlerService.implicitFlowCallback(config, allConfigs, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processRefreshToken(config, allConfigs, customParamsRefresh) {\n    return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(config).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, config, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n}\n\nFlowsService.ɵfac = function FlowsService_Factory(t) {\n  return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n};\n\nFlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsService,\n  factory: FlowsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CodeFlowCallbackHandlerService\n    }, {\n      type: ImplicitFlowCallbackHandlerService\n    }, {\n      type: HistoryJwtKeysCallbackHandlerService\n    }, {\n      type: UserCallbackHandlerService\n    }, {\n      type: StateValidationCallbackHandlerService\n    }, {\n      type: RefreshSessionCallbackHandlerService\n    }, {\n      type: RefreshTokenCallbackHandlerService\n    }];\n  }, null);\n})();\n\nclass IntervalService {\n  constructor(zone) {\n    this.zone = zone;\n    this.runTokenValidationRunning = null;\n  }\n\n  isTokenValidationRunning() {\n    return !!this.runTokenValidationRunning;\n  }\n\n  stopPeriodicTokenCheck() {\n    if (this.runTokenValidationRunning) {\n      this.runTokenValidationRunning.unsubscribe();\n      this.runTokenValidationRunning = null;\n    }\n  }\n\n  startPeriodicTokenCheck(repeatAfterSeconds) {\n    const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n    return new Observable(subscriber => {\n      let intervalId;\n      this.zone.runOutsideAngular(() => {\n        intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n      });\n      return () => {\n        clearInterval(intervalId);\n      };\n    });\n  }\n\n}\n\nIntervalService.ɵfac = function IntervalService_Factory(t) {\n  return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n};\n\nIntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IntervalService,\n  factory: IntervalService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IntervalService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackService {\n  constructor(flowsService, router, flowsDataService, intervalService) {\n    this.flowsService = flowsService;\n    this.router = router;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n  }\n\n  authenticatedImplicitFlowCallback(config, allConfigs, hash) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = config;\n    return this.flowsService.processImplicitFlowCallback(config, allConfigs, hash).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(config);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n  return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n};\n\nImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackService,\n  factory: ImplicitFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: i2.Router\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\nclass SilentRenewService {\n  constructor(iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n    this.iFrameService = iFrameService;\n    this.flowsService = flowsService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsDataService = flowsDataService;\n    this.authStateService = authStateService;\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.intervalService = intervalService;\n    this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n  }\n\n  get refreshSessionWithIFrameCompleted$() {\n    return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n  }\n\n  getOrCreateIframe(config) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, config);\n    }\n\n    return existingIframe;\n  }\n\n  isSilentRenewConfigured(configuration) {\n    const {\n      useRefreshToken,\n      silentRenew\n    } = configuration;\n    return !useRefreshToken && silentRenew;\n  }\n\n  codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs) {\n    const params = new HttpParams({\n      fromString: urlParts[1]\n    });\n    const error = params.get('error');\n\n    if (error) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: ValidationResult.LoginRequired,\n        isRenewProcess: true\n      });\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      this.flowsDataService.setNonce('', config);\n      this.intervalService.stopPeriodicTokenCheck();\n      return throwError(() => new Error(error));\n    }\n\n    const code = params.get('code');\n    const state = params.get('state');\n    const sessionState = params.get('session_state');\n    const callbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: true,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, config, allConfigs).pipe(catchError(() => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n  silentRenewEventHandler(e, config, allConfigs) {\n    this.loggerService.logDebug(config, 'silentRenewEventHandler');\n\n    if (!e.detail) {\n      return;\n    }\n\n    let callback$ = of(null);\n    const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(config);\n\n    if (isCodeFlow) {\n      const urlParts = e.detail.toString().split('?');\n      callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs);\n    } else {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, e.detail);\n    }\n\n    callback$.subscribe({\n      next: callbackContext => {\n        this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n        this.flowsDataService.resetSilentRenewRunning(config);\n      },\n      error: err => {\n        this.loggerService.logError(config, 'Error: ' + err);\n        this.refreshSessionWithIFrameCompletedInternal$.next(null);\n        this.flowsDataService.resetSilentRenewRunning(config);\n      }\n    });\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n  }\n\n}\n\nSilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n  return new (t || SilentRenewService)(i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n};\n\nSilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SilentRenewService,\n  factory: SilentRenewService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SilentRenewService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: IFrameService\n    }, {\n      type: FlowsService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackService {\n  constructor(flowsService, flowsDataService, intervalService, router) {\n    this.flowsService = flowsService;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n    this.router = router;\n  }\n\n  authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = config;\n    return this.flowsService.processCodeFlowCallback(urlToCheck, config, allConfigs).pipe(tap(callbackContext => {\n      this.flowsDataService.resetCodeFlowInProgress(config);\n\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(config);\n      this.flowsDataService.resetCodeFlowInProgress(config);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nCodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n  return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(i2.Router));\n};\n\nCodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackService,\n  factory: CodeFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CallbackService {\n  constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n    this.urlService = urlService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.codeFlowCallbackService = codeFlowCallbackService;\n    this.stsCallbackInternal$ = new Subject();\n  }\n\n  get stsCallback$() {\n    return this.stsCallbackInternal$.asObservable();\n  }\n\n  isCallback(currentUrl) {\n    return this.urlService.isCallbackFromSts(currentUrl);\n  }\n\n  handleCallbackAndFireEvents(currentCallbackUrl, config, allConfigs) {\n    let callback$;\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, config, allConfigs);\n    } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(config)) {\n      if (currentCallbackUrl === null || currentCallbackUrl === void 0 ? void 0 : currentCallbackUrl.includes('#')) {\n        let hash = currentCallbackUrl.substring(currentCallbackUrl.indexOf('#') + 1);\n        callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, hash);\n      } else {\n        callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs);\n      }\n    }\n\n    return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n  }\n\n}\n\nCallbackService.ɵfac = function CallbackService_Factory(t) {\n  return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n};\n\nCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CallbackService,\n  factory: CallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: CodeFlowCallbackService\n    }];\n  }, null);\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\n\nclass AuthWellKnownDataService {\n  constructor(http, loggerService) {\n    this.http = http;\n    this.loggerService = loggerService;\n  }\n\n  getWellKnownEndPointsForConfig(config) {\n    const {\n      authWellknownEndpointUrl\n    } = config;\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    return this.getWellKnownDocument(authWellknownEndpointUrl, config).pipe(map(wellKnownEndpoints => ({\n      issuer: wellKnownEndpoints.issuer,\n      jwksUri: wellKnownEndpoints.jwks_uri,\n      authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n      tokenEndpoint: wellKnownEndpoints.token_endpoint,\n      userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n      endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n      checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n      revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n      introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n      parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n    })));\n  }\n\n  getWellKnownDocument(wellKnownEndpoint, config) {\n    let url = wellKnownEndpoint;\n\n    if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n      url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n    }\n\n    return this.http.get(url, config).pipe(retry(2));\n  }\n\n}\n\nAuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n  return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService), i0.ɵɵinject(LoggerService));\n};\n\nAuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownDataService,\n  factory: AuthWellKnownDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass AuthWellKnownService {\n  constructor(dataService, publicEventsService, storagePersistenceService) {\n    this.dataService = dataService;\n    this.publicEventsService = publicEventsService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  storeWellKnownEndpoints(config, mappedWellKnownEndpoints) {\n    this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, config);\n  }\n\n  queryAndStoreAuthWellKnownEndPoints(config) {\n    const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n    if (!!alreadySavedWellKnownEndpoints) {\n      return of(alreadySavedWellKnownEndpoints);\n    }\n\n    return this.dataService.getWellKnownEndPointsForConfig(config).pipe(tap(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(config, mappedWellKnownEndpoints)), catchError(error => {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nAuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n  return new (t || AuthWellKnownService)(i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nAuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownService,\n  factory: AuthWellKnownService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthWellKnownDataService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass RefreshSessionIframeService {\n  constructor(document, loggerService, urlService, silentRenewService, rendererFactory) {\n    this.document = document;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.silentRenewService = silentRenewService;\n    this.renderer = rendererFactory.createRenderer(null, null);\n  }\n\n  refreshSessionWithIframe(config, allConfigs, customParams) {\n    this.loggerService.logDebug(config, 'BEGIN refresh session Authorize Iframe renew');\n    return this.urlService.getRefreshSessionSilentRenewUrl(config, customParams).pipe(switchMap(url => {\n      return this.sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs);\n    }));\n  }\n\n  sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs) {\n    const sessionIframe = this.silentRenewService.getOrCreateIframe(config);\n    this.initSilentRenewRequest(config, allConfigs);\n    this.loggerService.logDebug(config, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n    return new Observable(observer => {\n      const onLoadHandler = () => {\n        sessionIframe.removeEventListener('load', onLoadHandler);\n        this.loggerService.logDebug(config, 'removed event listener from IFrame');\n        observer.next(true);\n        observer.complete();\n      };\n\n      sessionIframe.addEventListener('load', onLoadHandler);\n      sessionIframe.contentWindow.location.replace(url);\n    });\n  }\n\n  initSilentRenewRequest(config, allConfigs) {\n    const instanceId = Math.random();\n    const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n      if (e.detail !== instanceId) {\n        initDestroyHandler();\n        renewDestroyHandler();\n      }\n    });\n    const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, config, allConfigs));\n    this.document.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n      detail: instanceId\n    }));\n  }\n\n}\n\nRefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n  return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n};\n\nRefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionIframeService,\n  factory: RefreshSessionIframeService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionIframeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\nclass RefreshSessionRefreshTokenService {\n  constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n    this.loggerService = loggerService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsService = flowsService;\n    this.intervalService = intervalService;\n  }\n\n  refreshSessionWithRefreshTokens(config, allConfigs, customParamsRefresh) {\n    this.loggerService.logDebug(config, 'BEGIN refresh session Authorize');\n    let refreshTokenFailed = false;\n    return this.flowsService.processRefreshToken(config, allConfigs, customParamsRefresh).pipe(catchError(error => {\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      refreshTokenFailed = true;\n      return throwError(() => new Error(error));\n    }), finalize(() => refreshTokenFailed && this.intervalService.stopPeriodicTokenCheck()));\n  }\n\n}\n\nRefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n  return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n};\n\nRefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionRefreshTokenService,\n  factory: RefreshSessionRefreshTokenService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionRefreshTokenService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\n\nclass RefreshSessionService {\n  constructor(flowHelper, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n    this.flowHelper = flowHelper;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.silentRenewService = silentRenewService;\n    this.authStateService = authStateService;\n    this.authWellKnownService = authWellKnownService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.userService = userService;\n  }\n\n  userForceRefreshSession(config, allConfigs, extraCustomParams) {\n    this.persistCustomParams(extraCustomParams, config);\n    return this.forceRefreshSession(config, allConfigs, extraCustomParams);\n  }\n\n  forceRefreshSession(config, allConfigs, extraCustomParams) {\n    const {\n      customParamsRefreshTokenRequest,\n      configId\n    } = config;\n    const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n      return this.startRefreshSession(config, allConfigs, mergedParams).pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n        if (isAuthenticated) {\n          return {\n            idToken: this.authStateService.getIdToken(config),\n            accessToken: this.authStateService.getAccessToken(config),\n            userData: this.userService.getUserDataFromStore(config),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = config;\n    const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n    return forkJoin([this.startRefreshSession(config, allConfigs, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n      var _a, _b;\n\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n      if (isAuthenticated) {\n        return {\n          idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\n          accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\n          userData: this.userService.getUserDataFromStore(config),\n          isAuthenticated,\n          configId\n        };\n      }\n\n      return null;\n    }));\n  }\n\n  persistCustomParams(extraCustomParams, config) {\n    const {\n      useRefreshToken\n    } = config;\n\n    if (extraCustomParams) {\n      if (useRefreshToken) {\n        this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, config);\n      } else {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, config);\n      }\n    }\n  }\n\n  startRefreshSession(config, allConfigs, extraCustomParams) {\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n    this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n    const shouldBeExecuted = !isSilentRenewRunning;\n\n    if (!shouldBeExecuted) {\n      return of(null);\n    }\n\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config).pipe(switchMap(() => {\n      this.flowsDataService.setSilentRenewRunning(config);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n        // Refresh Session using Refresh tokens\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, extraCustomParams);\n      }\n\n      return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, extraCustomParams);\n    }));\n  }\n\n  timeoutRetryStrategy(errorAttempts, config) {\n    return errorAttempts.pipe(mergeMap((error, index) => {\n      const scalingDuration = 1000;\n      const currentAttempt = index + 1;\n\n      if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n        return throwError(() => new Error(error));\n      }\n\n      this.loggerService.logDebug(config, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n      this.flowsDataService.resetSilentRenewRunning(config);\n      return timer(currentAttempt * scalingDuration);\n    }));\n  }\n\n}\n\nRefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n  return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n};\n\nRefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionService,\n  factory: RefreshSessionService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowHelper\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: AuthStateService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  disableRefreshIdTokenAuthTimeValidation: false,\n  triggerRefreshWhenIdTokenExpired: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  if (!passedConfig) {\n    return null;\n  }\n\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const someAreNull = allIdentifiers.some(x => x === null);\n\n  if (someAreNull) {\n    return {\n      result: false,\n      messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\n      level: 'error'\n    };\n  }\n\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectUrl is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  validateConfigs(passedConfigs) {\n    return this.validateConfigsInternal(passedConfigs !== null && passedConfigs !== void 0 ? passedConfigs : [], allMultipleConfigRules);\n  }\n\n  validateConfig(passedConfig) {\n    return this.validateConfigInternal(passedConfig, allRules);\n  }\n\n  validateConfigsInternal(passedConfigs, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n    let overallErrorCount = 0;\n    passedConfigs.forEach(passedConfig => {\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n      overallErrorCount += errorCount;\n    });\n    return overallErrorCount === 0;\n  }\n\n  validateConfigInternal(passedConfig, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n    const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n    return errorCount === 0;\n  }\n\n  processValidationResultsAndGetErrorCount(allValidationResults, config) {\n    const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n    const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n    const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n    allErrorMessages.forEach(message => this.loggerService.logError(config, message));\n    allWarnings.forEach(message => this.loggerService.logWarning(config, message));\n    return allErrorMessages.length;\n  }\n\n  getAllMessagesOfType(type, results) {\n    const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n    return allMessages.reduce((acc, val) => acc.concat(val), []);\n  }\n\n}\n\nConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n  return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n};\n\nConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigValidationService,\n  factory: ConfigValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass PlatformProvider {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  isBrowser() {\n    return isPlatformBrowser(this.platformId);\n  }\n\n}\n\nPlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n  return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nPlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PlatformProvider,\n  factory: PlatformProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformProvider, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      return of(this.passedConfigs);\n    }\n\n    return of([this.passedConfigs]);\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.configs$)) {\n      return forkJoin(this.configs$);\n    }\n\n    const singleConfigOrArray = this.configs$;\n    return singleConfigOrArray.pipe(map(value => {\n      if (Array.isArray(value)) {\n        return value;\n      }\n\n      return [value];\n    }));\n  }\n\n}\n\nclass ConfigurationService {\n  constructor(loggerService, publicEventsService, storagePersistenceService, configValidationService, platformProvider, authWellKnownService, loader) {\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.configValidationService = configValidationService;\n    this.platformProvider = platformProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.loader = loader;\n    this.configsInternal = {};\n  }\n\n  hasManyConfigs() {\n    return Object.keys(this.configsInternal).length > 1;\n  }\n\n  getAllConfigurations() {\n    return Object.values(this.configsInternal);\n  }\n\n  getOpenIDConfiguration(configId) {\n    if (this.configsAlreadySaved()) {\n      return of(this.getConfig(configId));\n    }\n\n    return this.getOpenIDConfigurations(configId).pipe(map(result => result.currentConfig));\n  }\n\n  getOpenIDConfigurations(configId) {\n    return this.loadConfigs().pipe(concatMap(allConfigs => this.prepareAndSaveConfigs(allConfigs)), map(allPreparedConfigs => ({\n      allConfigs: allPreparedConfigs,\n      currentConfig: this.getConfig(configId)\n    })));\n  }\n\n  hasAtLeastOneConfig() {\n    return Object.keys(this.configsInternal).length > 0;\n  }\n\n  saveConfig(readyConfig) {\n    const {\n      configId\n    } = readyConfig;\n    this.configsInternal[configId] = readyConfig;\n  }\n\n  loadConfigs() {\n    return this.loader.loadConfigs();\n  }\n\n  configsAlreadySaved() {\n    return this.hasAtLeastOneConfig();\n  }\n\n  getConfig(configId) {\n    if (!!configId) {\n      return this.configsInternal[configId] || null;\n    }\n\n    const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n    return value || null;\n  }\n\n  prepareAndSaveConfigs(passedConfigs) {\n    if (!this.configValidationService.validateConfigs(passedConfigs)) {\n      return of(null);\n    }\n\n    this.createUniqueIds(passedConfigs);\n    const allHandleConfigs$ = passedConfigs.map(x => this.handleConfig(x));\n    return forkJoin(allHandleConfigs$);\n  }\n\n  createUniqueIds(passedConfigs) {\n    passedConfigs.forEach((config, index) => {\n      if (!config.configId) {\n        config.configId = `${index}-${config.clientId}`;\n      }\n    });\n  }\n\n  handleConfig(passedConfig) {\n    if (!this.configValidationService.validateConfig(passedConfig)) {\n      this.loggerService.logError(passedConfig, 'Validation of config rejected with errors. Config is NOT set.');\n      return of(null);\n    }\n\n    if (!passedConfig.authWellknownEndpointUrl) {\n      passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n    }\n\n    const usedConfig = this.prepareConfig(passedConfig);\n    this.saveConfig(usedConfig);\n    const configWithAuthWellKnown = this.enhanceConfigWithWellKnownEndpoint(usedConfig);\n    this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, configWithAuthWellKnown);\n    return of(usedConfig);\n  }\n\n  enhanceConfigWithWellKnownEndpoint(configuration) {\n    const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!!alreadyExistingAuthWellKnownEndpoints) {\n      configuration.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n      return configuration;\n    }\n\n    const passedAuthWellKnownEndpoints = configuration.authWellknownEndpoints;\n\n    if (!!passedAuthWellKnownEndpoints) {\n      this.authWellKnownService.storeWellKnownEndpoints(configuration, passedAuthWellKnownEndpoints);\n      configuration.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n      return configuration;\n    }\n\n    return configuration;\n  }\n\n  prepareConfig(configuration) {\n    const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\n    this.setSpecialCases(openIdConfigurationInternal);\n    return openIdConfigurationInternal;\n  }\n\n  setSpecialCases(currentConfig) {\n    if (!this.platformProvider.isBrowser()) {\n      currentConfig.startCheckSession = false;\n      currentConfig.silentRenew = false;\n      currentConfig.useRefreshToken = false;\n      currentConfig.usePushedAuthorisationRequests = false;\n    }\n  }\n\n}\n\nConfigurationService.ɵfac = function ConfigurationService_Factory(t) {\n  return new (t || ConfigurationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StsConfigLoader));\n};\n\nConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigurationService,\n  factory: ConfigurationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigurationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ConfigValidationService\n    }, {\n      type: PlatformProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: StsConfigLoader\n    }];\n  }, null);\n})();\n\nclass PeriodicallyTokenCheckService {\n  constructor(resetAuthDataService, flowHelper, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService, configurationService) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowHelper = flowHelper;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.userService = userService;\n    this.authStateService = authStateService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.intervalService = intervalService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n    this.configurationService = configurationService;\n  }\n\n  startTokenValidationPeriodically(allConfigs, currentConfig) {\n    const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled(allConfigs);\n\n    if (configsWithSilentRenewEnabled.length <= 0) {\n      return;\n    }\n\n    if (this.intervalService.isTokenValidationRunning()) {\n      return;\n    }\n\n    const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n    const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n      const objectWithConfigIdsAndRefreshEvent = {};\n      configsWithSilentRenewEnabled.forEach(config => {\n        objectWithConfigIdsAndRefreshEvent[config.configId] = this.getRefreshEvent(config, allConfigs);\n      });\n      return forkJoin(objectWithConfigIdsAndRefreshEvent);\n    }));\n    this.intervalService.runTokenValidationRunning = periodicallyCheck$.pipe(catchError(error => throwError(() => new Error(error)))).subscribe({\n      next: objectWithConfigIds => {\n        for (const [configId, _] of Object.entries(objectWithConfigIds)) {\n          this.configurationService.getOpenIDConfiguration(configId).subscribe(config => {\n            this.loggerService.logDebug(config, 'silent renew, periodic check finished!');\n\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n              this.flowsDataService.resetSilentRenewRunning(config);\n            }\n          });\n        }\n      },\n      error: error => {\n        this.loggerService.logError(currentConfig, 'silent renew failed!', error);\n      }\n    });\n  }\n\n  getRefreshEvent(config, allConfigs) {\n    const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(config);\n\n    if (!shouldStartRefreshEvent) {\n      return of(null);\n    }\n\n    const refreshEvent$ = this.createRefreshEventForConfig(config, allConfigs);\n    this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n    const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n      this.loggerService.logError(config, 'silent renew failed!', error);\n      this.publicEventsService.fireEvent(EventTypes.SilentRenewFailed, error);\n      this.flowsDataService.resetSilentRenewRunning(config);\n      return throwError(() => new Error(error));\n    }));\n    return refreshEventWithErrorHandler$;\n  }\n\n  getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n    const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n    return result.tokenRefreshInSeconds;\n  }\n\n  getConfigsWithSilentRenewEnabled(allConfigs) {\n    return allConfigs.filter(x => x.silentRenew);\n  }\n\n  createRefreshEventForConfig(configuration, allConfigs) {\n    this.loggerService.logDebug(configuration, 'starting silent renew...');\n    return this.configurationService.getOpenIDConfiguration(configuration.configId).pipe(switchMap(config => {\n      if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        return of(null);\n      }\n\n      this.flowsDataService.setSilentRenewRunning(config);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n        // Retrieve Dynamically Set Custom Params for refresh body\n        const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', config) || {};\n        const {\n          customParamsRefreshTokenRequest\n        } = config;\n        const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh); // Refresh Session using Refresh tokens\n\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, mergedParams);\n      } // Retrieve Dynamically Set Custom Params\n\n\n      const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', config);\n      return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, customParams);\n    }));\n  }\n\n  shouldStartPeriodicallyCheckForConfig(config) {\n    const idToken = this.authStateService.getIdToken(config);\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n    const isCodeFlowinProgress = this.flowsDataService.isCodeFlowInProgress(config);\n    const userDataFromStore = this.userService.getUserDataFromStore(config);\n    this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}, isCodeFlowInProgress: ${isCodeFlowinProgress} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n    const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken && !isCodeFlowinProgress;\n\n    if (!shouldBeExecuted) {\n      return false;\n    }\n\n    const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(config);\n\n    if (!accessTokenHasExpired) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nPeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n  return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationService));\n};\n\nPeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PeriodicallyTokenCheckService,\n  factory: PeriodicallyTokenCheckService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PeriodicallyTokenCheckService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: UserService\n    }, {\n      type: AuthStateService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: IntervalService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationService\n    }];\n  }, null);\n})();\n\nclass PopUpService {\n  constructor(document, loggerService, storagePersistenceService) {\n    this.document = document;\n    this.loggerService = loggerService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.STORAGE_IDENTIFIER = 'popupauth';\n    this.resultInternal$ = new Subject();\n  }\n\n  get result$() {\n    return this.resultInternal$.asObservable();\n  }\n\n  get windowInternal() {\n    return this.document.defaultView;\n  }\n\n  currentWindowIsPopUp() {\n    return !!this.windowInternal.opener && this.windowInternal.opener !== this.windowInternal;\n  }\n\n  isCurrentlyInPopup(config) {\n    if (this.canAccessSessionStorage()) {\n      const mainWindowHasPopupOpen = this.mainWindowHasPopupOpen(config);\n      const currentWindowIsPopup = this.currentWindowIsPopUp();\n      return mainWindowHasPopupOpen || currentWindowIsPopup;\n    }\n\n    return false;\n  }\n\n  openPopUp(url, popupOptions, config) {\n    const optionsToPass = this.getOptions(popupOptions);\n    this.popUp = this.windowInternal.open(url, '_blank', optionsToPass);\n\n    if (!this.popUp) {\n      this.loggerService.logError(config, 'Could not open popup');\n      return;\n    }\n\n    this.storagePersistenceService.write(this.STORAGE_IDENTIFIER, 'true', config);\n\n    const listener = event => {\n      if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\n        this.cleanUp(listener, config);\n        return;\n      }\n\n      this.resultInternal$.next({\n        userClosed: false,\n        receivedUrl: event.data\n      });\n      this.cleanUp(listener, config);\n    };\n\n    this.windowInternal.addEventListener('message', listener, false);\n    this.handle = this.windowInternal.setInterval(() => {\n      var _a;\n\n      if ((_a = this.popUp) === null || _a === void 0 ? void 0 : _a.closed) {\n        this.resultInternal$.next({\n          userClosed: true\n        });\n        this.cleanUp(listener, config);\n      }\n    }, 200);\n  }\n\n  sendMessageToMainWindow(url) {\n    if (this.windowInternal.opener) {\n      const href = this.windowInternal.location.href;\n      this.sendMessage(url, href);\n    }\n  }\n\n  cleanUp(listener, config) {\n    this.windowInternal.removeEventListener('message', listener, false);\n    this.windowInternal.clearInterval(this.handle);\n\n    if (this.popUp) {\n      this.storagePersistenceService.remove(this.STORAGE_IDENTIFIER, config);\n      this.popUp.close();\n      this.popUp = null;\n    }\n  }\n\n  sendMessage(url, href) {\n    this.windowInternal.opener.postMessage(url, href);\n  }\n\n  getOptions(popupOptions) {\n    const popupDefaultOptions = {\n      width: 500,\n      height: 500,\n      left: 50,\n      top: 50\n    };\n    const options = Object.assign(Object.assign({}, popupDefaultOptions), popupOptions || {});\n    const left = this.windowInternal.screenLeft + (this.windowInternal.outerWidth - options.width) / 2;\n    const top = this.windowInternal.screenTop + (this.windowInternal.outerHeight - options.height) / 2;\n    options.left = left;\n    options.top = top;\n    return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n  }\n\n  mainWindowHasPopupOpen(config) {\n    return !!this.storagePersistenceService.read(this.STORAGE_IDENTIFIER, config);\n  }\n\n  canAccessSessionStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nPopUpService.ɵfac = function PopUpService_Factory(t) {\n  return new (t || PopUpService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nPopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpService,\n  factory: PopUpService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nconst STORAGE_KEY = 'redirect';\n\nclass AutoLoginService {\n  constructor(storageService, router) {\n    this.storageService = storageService;\n    this.router = router;\n  }\n\n  checkSavedRedirectRouteAndNavigate(config) {\n    const savedRouteForRedirect = this.getStoredRedirectRoute(config);\n\n    if (savedRouteForRedirect) {\n      this.deleteStoredRedirectRoute(config);\n      this.router.navigateByUrl(savedRouteForRedirect);\n    }\n  }\n  /**\r\n   * Saves the redirect URL to storage.\r\n   *\r\n   * @param url The redirect URL to save.\r\n   */\n\n\n  saveRedirectRoute(config, url) {\n    this.storageService.write(STORAGE_KEY, url, config);\n  }\n  /**\r\n   * Gets the stored redirect URL from storage.\r\n   */\n\n\n  getStoredRedirectRoute(config) {\n    return this.storageService.read(STORAGE_KEY, config);\n  }\n  /**\r\n   * Removes the redirect URL from storage.\r\n   */\n\n\n  deleteStoredRedirectRoute(config) {\n    this.storageService.remove(STORAGE_KEY, config);\n  }\n\n}\n\nAutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n  return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginService,\n  factory: AutoLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CheckAuthService {\n  constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService, publicEventsService) {\n    this.checkSessionService = checkSessionService;\n    this.currentUrlService = currentUrlService;\n    this.silentRenewService = silentRenewService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.callbackService = callbackService;\n    this.refreshSessionService = refreshSessionService;\n    this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n    this.popupService = popupService;\n    this.autoLoginService = autoLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n  }\n\n  checkAuth(configuration, allConfigs, url) {\n    this.publicEventsService.fireEvent(EventTypes.CheckingAuth);\n    const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl(url);\n\n    if (!!stateParamFromUrl) {\n      configuration = this.getConfigurationWithUrlState([configuration], stateParamFromUrl);\n\n      if (!configuration) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n    }\n\n    return this.checkAuthWithConfig(configuration, allConfigs, url);\n  }\n\n  checkAuthMultiple(allConfigs, url) {\n    const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl(url);\n\n    if (stateParamFromUrl) {\n      const config = this.getConfigurationWithUrlState(allConfigs, stateParamFromUrl);\n\n      if (!config) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n\n      return this.composeMultipleLoginResults(allConfigs, config, url);\n    }\n\n    const configs = allConfigs;\n    const allChecks$ = configs.map(x => this.checkAuthWithConfig(x, configs, url));\n    return forkJoin(allChecks$);\n  }\n\n  checkAuthIncludingServer(configuration, allConfigs) {\n    return this.checkAuthWithConfig(configuration, allConfigs).pipe(switchMap(loginResponse => {\n      const {\n        isAuthenticated\n      } = loginResponse;\n\n      if (isAuthenticated) {\n        return of(loginResponse);\n      }\n\n      return this.refreshSessionService.forceRefreshSession(configuration, allConfigs).pipe(tap(loginResponseAfterRefreshSession => {\n        if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\n          this.startCheckSessionAndValidation(configuration, allConfigs);\n        }\n      }));\n    }));\n  }\n\n  checkAuthWithConfig(config, allConfigs, url) {\n    if (!config) {\n      const errorMessage = 'Please provide at least one configuration before setting up the module';\n      this.loggerService.logError(config, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId: null\n      });\n    }\n\n    const currentUrl = url || this.currentUrlService.getCurrentUrl();\n    const {\n      configId,\n      authority\n    } = config;\n    this.loggerService.logDebug(config, `Working with config '${configId}' using ${authority}`);\n\n    if (this.popupService.currentWindowIsPopUp()) {\n      this.popupService.sendMessageToMainWindow(currentUrl);\n      return of(null);\n    }\n\n    const isCallback = this.callbackService.isCallback(currentUrl);\n    this.loggerService.logDebug(config, 'currentUrl to check auth with: ', currentUrl);\n    const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, config, allConfigs) : of(null);\n    return callback$.pipe(map(() => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n      if (isAuthenticated) {\n        this.startCheckSessionAndValidation(config, allConfigs);\n\n        if (!isCallback) {\n          this.authStateService.setAuthenticatedAndFireEvent(allConfigs);\n          this.userService.publishUserDataIfExists(config, allConfigs);\n        }\n      }\n\n      this.loggerService.logDebug(config, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n      return {\n        isAuthenticated,\n        userData: this.userService.getUserDataFromStore(config),\n        accessToken: this.authStateService.getAccessToken(config),\n        idToken: this.authStateService.getIdToken(config),\n        configId\n      };\n    }), tap(({\n      isAuthenticated\n    }) => {\n      this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinished);\n\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n      }\n    }), catchError(({\n      message\n    }) => {\n      this.loggerService.logError(config, message);\n      this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinishedWithError, message);\n      return of({\n        isAuthenticated: false,\n        errorMessage: message,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }));\n  }\n\n  startCheckSessionAndValidation(config, allConfigs) {\n    if (this.checkSessionService.isCheckSessionConfigured(config)) {\n      this.checkSessionService.start(config);\n    }\n\n    this.periodicallyTokenCheckService.startTokenValidationPeriodically(allConfigs, config);\n\n    if (this.silentRenewService.isSilentRenewConfigured(config)) {\n      this.silentRenewService.getOrCreateIframe(config);\n    }\n  }\n\n  getConfigurationWithUrlState(configurations, stateFromUrl) {\n    for (const config of configurations) {\n      const storedState = this.storagePersistenceService.read('authStateControl', config);\n\n      if (storedState === stateFromUrl) {\n        return config;\n      }\n    }\n\n    return null;\n  }\n\n  composeMultipleLoginResults(configurations, activeConfig, url) {\n    const allOtherConfigs = configurations.filter(x => x.configId !== activeConfig.configId);\n    const currentConfigResult = this.checkAuthWithConfig(activeConfig, configurations, url);\n    const allOtherConfigResults = allOtherConfigs.map(config => {\n      const {\n        redirectUrl\n      } = config;\n      return this.checkAuthWithConfig(config, configurations, redirectUrl);\n    });\n    return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n  }\n\n}\n\nCheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n  return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService));\n};\n\nCheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckAuthService,\n  factory: CheckAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CurrentUrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: CallbackService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: PeriodicallyTokenCheckService\n    }, {\n      type: PopUpService\n    }, {\n      type: AutoLoginService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }];\n  }, null);\n})();\n\nclass ClosestMatchingRouteService {\n  getConfigIdForClosestMatchingRoute(route, configurations) {\n    for (const config of configurations) {\n      const {\n        secureRoutes\n      } = config;\n\n      for (const configuredRoute of secureRoutes) {\n        if (route.startsWith(configuredRoute)) {\n          return {\n            matchingRoute: configuredRoute,\n            matchingConfig: config\n          };\n        }\n      }\n    }\n\n    return {\n      matchingRoute: null,\n      matchingConfig: null\n    };\n  }\n\n}\n\nClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n  return new (t || ClosestMatchingRouteService)();\n};\n\nClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ClosestMatchingRouteService,\n  factory: ClosestMatchingRouteService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ClosestMatchingRouteService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ConsoleLoggerService {\n  logError(message, ...args) {\n    console.error(message, ...args);\n  }\n\n  logWarning(message, ...args) {\n    console.warn(message, ...args);\n  }\n\n  logDebug(message, ...args) {\n    console.debug(message, ...args);\n  }\n\n}\n\nConsoleLoggerService.ɵfac = function ConsoleLoggerService_Factory(t) {\n  return new (t || ConsoleLoggerService)();\n};\n\nConsoleLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConsoleLoggerService,\n  factory: ConsoleLoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConsoleLoggerService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ResponseTypeValidationService {\n  constructor(loggerService, flowHelper) {\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n  }\n\n  hasConfigValidResponseType(configuration) {\n    if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configuration)) {\n      return true;\n    }\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\n      return true;\n    }\n\n    this.loggerService.logWarning(configuration, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n    return false;\n  }\n\n}\n\nResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n  return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n};\n\nResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResponseTypeValidationService,\n  factory: ResponseTypeValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResponseTypeValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass RedirectService {\n  constructor(document) {\n    this.document = document;\n  }\n\n  redirectTo(url) {\n    this.document.location.href = url;\n  }\n\n}\n\nRedirectService.ɵfac = function RedirectService_Factory(t) {\n  return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n};\n\nRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RedirectService,\n  factory: RedirectService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RedirectService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParService {\n  constructor(loggerService, urlService, dataService, storagePersistenceService) {\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  postParRequest(configuration, customParams) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndpoints) {\n      return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\n    }\n\n    const parEndpoint = authWellKnownEndpoints.parEndpoint;\n\n    if (!parEndpoint) {\n      return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\n    }\n\n    return this.urlService.createBodyForParCodeFlowRequest(configuration, customParams).pipe(switchMap(data => {\n      return this.dataService.post(parEndpoint, data, configuration, headers).pipe(retry(2), map(response => {\n        this.loggerService.logDebug(configuration, 'par response: ', response);\n        return {\n          expiresIn: response.expires_in,\n          requestUri: response.request_uri\n        };\n      }), catchError(error => {\n        const errorMessage = `There was an error on ParService postParRequest`;\n        this.loggerService.logError(configuration, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }));\n  }\n\n}\n\nParService.ɵfac = function ParService_Factory(t) {\n  return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParService,\n  factory: ParService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass ParLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, popupService, checkAuthService, parService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n    this.parService = parService;\n  }\n\n  loginPar(configuration, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      this.loggerService.logError(configuration, 'Invalid response type!');\n      return;\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams))).subscribe(response => {\n      this.loggerService.logDebug(configuration, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n      this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n      if (!url) {\n        this.loggerService.logError(configuration, `Could not create URL with param ${response.requestUri}: '${url}'`);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n  loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    const {\n      customParams\n    } = authOptions || {};\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)), switchMap(response => {\n      this.loggerService.logDebug(configuration, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n      this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n      if (!url) {\n        const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\n        this.loggerService.logError(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.popupService.openPopUp(url, popupOptions, configuration);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nParLoginService.ɵfac = function ParLoginService_Factory(t) {\n  return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n};\n\nParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParLoginService,\n  factory: ParLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: ParService\n    }];\n  }, null);\n})();\n\nclass PopUpLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, authWellKnownService, popupService, checkAuthService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n  }\n\n  loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.urlService.getAuthorizeUrl(configuration, authOptions)), tap(authUrl => this.popupService.openPopUp(authUrl, popupOptions, configuration)), switchMap(() => {\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nPopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n  return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n};\n\nPopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpLoginService,\n  factory: PopUpLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }];\n  }, null);\n})();\n\nclass StandardLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.authWellKnownService = authWellKnownService;\n    this.flowsDataService = flowsDataService;\n  }\n\n  loginStandard(configuration, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      this.loggerService.logError(configuration, 'Invalid response type!');\n      return;\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n    this.flowsDataService.setCodeFlowInProgress(configuration);\n    this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).subscribe(() => {\n      const {\n        urlHandler\n      } = authOptions || {};\n      this.flowsDataService.resetSilentRenewRunning(configuration);\n      this.urlService.getAuthorizeUrl(configuration, authOptions).subscribe(url => {\n        if (!url) {\n          this.loggerService.logError(configuration, 'Could not create URL', url);\n          return;\n        }\n\n        if (urlHandler) {\n          urlHandler(url);\n        } else {\n          this.redirectService.redirectTo(url);\n        }\n      });\n    });\n  }\n\n}\n\nStandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n  return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(FlowsDataService));\n};\n\nStandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StandardLoginService,\n  factory: StandardLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StandardLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass LoginService {\n  constructor(parLoginService, popUpLoginService, standardLoginService, storagePersistenceService, popupService) {\n    this.parLoginService = parLoginService;\n    this.popUpLoginService = popUpLoginService;\n    this.standardLoginService = standardLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.popupService = popupService;\n  }\n\n  login(configuration, authOptions) {\n    const {\n      usePushedAuthorisationRequests\n    } = configuration;\n\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n    }\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginPar(configuration, authOptions);\n    } else {\n      return this.standardLoginService.loginStandard(configuration, authOptions);\n    }\n  }\n\n  loginWithPopUp(configuration, allConfigs, authOptions, popupOptions) {\n    const isAlreadyInPopUp = this.popupService.isCurrentlyInPopup(configuration);\n\n    if (isAlreadyInPopUp) {\n      return of({\n        errorMessage: 'There is already a popup open.'\n      });\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = configuration;\n\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n    }\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions);\n    }\n\n    return this.popUpLoginService.loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions);\n  }\n\n}\n\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PopUpService));\n};\n\nLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ParLoginService\n    }, {\n      type: PopUpLoginService\n    }, {\n      type: StandardLoginService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PopUpService\n    }];\n  }, null);\n})();\n\nfunction removeNullAndUndefinedValues(obj) {\n  const copy = Object.assign({}, obj);\n\n  for (const key in obj) {\n    if (obj[key] === undefined || obj[key] === null) {\n      delete copy[key];\n    }\n  }\n\n  return copy;\n}\n\nclass LogoffRevocationService {\n  constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService) {\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.checkSessionService = checkSessionService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.redirectService = redirectService;\n  } // Logs out on the server and the local client.\n  // If the server state has changed, check session, then only a local logout.\n\n\n  logoff(config, allConfigs, logoutAuthOptions) {\n    this.loggerService.logDebug(config, 'logoff, remove auth', logoutAuthOptions);\n    const {\n      urlHandler,\n      customParams\n    } = logoutAuthOptions || {};\n    const endSessionUrl = this.urlService.getEndSessionUrl(config, customParams);\n\n    if (!endSessionUrl) {\n      this.loggerService.logDebug(config, 'No endsessionUrl present. Logoff was only locally. Returning.');\n      return of(null);\n    }\n\n    if (this.checkSessionService.serverStateChanged(config)) {\n      this.loggerService.logDebug(config, 'Server State changed. Logoff was only locally. Returning.');\n      return of(null);\n    }\n\n    if (urlHandler) {\n      this.loggerService.logDebug(config, `Custom UrlHandler found. Using this to handle logoff with url '${endSessionUrl}'`);\n      urlHandler(endSessionUrl);\n      return of(null);\n    }\n\n    return this.logoffInternal(logoutAuthOptions, endSessionUrl, config, allConfigs);\n  }\n\n  logoffLocal(config, allConfigs) {\n    this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n    this.checkSessionService.stop();\n  }\n\n  logoffLocalMultiple(allConfigs) {\n    allConfigs.forEach(configuration => this.logoffLocal(configuration, allConfigs));\n  } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n  // only the access token is revoked. Then the logout run.\n\n\n  logoffAndRevokeTokens(config, allConfigs, logoutAuthOptions) {\n    const {\n      revocationEndpoint\n    } = this.storagePersistenceService.read('authWellKnownEndPoints', config) || {};\n\n    if (!revocationEndpoint) {\n      this.loggerService.logDebug(config, 'revocation endpoint not supported');\n      return this.logoff(config, allConfigs, logoutAuthOptions);\n    }\n\n    if (this.storagePersistenceService.getRefreshToken(config)) {\n      return this.revokeRefreshToken(config).pipe(switchMap(_ => this.revokeAccessToken(config)), catchError(error => {\n        const errorMessage = `revoke token failed`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), concatMap(() => this.logoff(config, allConfigs, logoutAuthOptions)));\n    } else {\n      return this.revokeAccessToken(config).pipe(catchError(error => {\n        const errorMessage = `revoke accessToken failed`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), concatMap(() => this.logoff(config, allConfigs, logoutAuthOptions)));\n    }\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an access token on the STS. If no token is provided, then the token from\n  // the storage is revoked. You can pass any token to revoke. This makes it possible to\n  // manage your own tokens. The is a public API.\n\n\n  revokeAccessToken(configuration, accessToken) {\n    const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configuration);\n    const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configuration);\n    return this.sendRevokeRequest(configuration, body);\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n  // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n  // This makes it possible to manage your own tokens.\n\n\n  revokeRefreshToken(configuration, refreshToken) {\n    const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configuration);\n    const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configuration);\n    return this.sendRevokeRequest(configuration, body);\n  }\n\n  logoffInternal(logoutAuthOptions, endSessionUrl, config, allConfigs) {\n    const {\n      logoffMethod,\n      customParams\n    } = logoutAuthOptions || {};\n\n    if (!logoffMethod || logoffMethod === 'GET') {\n      this.redirectService.redirectTo(endSessionUrl);\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      return of(null);\n    }\n\n    const {\n      state,\n      logout_hint,\n      ui_locales\n    } = customParams || {};\n    const {\n      clientId\n    } = config;\n    const idToken = this.storagePersistenceService.getIdToken(config);\n    const postLogoutRedirectUrl = this.urlService.getPostLogoutRedirectUrl(config);\n    const headers = this.getHeaders();\n    const {\n      url\n    } = this.urlService.getEndSessionEndpoint(config);\n    const body = {\n      id_token_hint: idToken,\n      client_id: clientId,\n      post_logout_redirect_uri: postLogoutRedirectUrl,\n      state,\n      logout_hint,\n      ui_locales\n    };\n    const bodyWithoutNullOrUndefined = removeNullAndUndefinedValues(body);\n    this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n    return this.dataService.post(url, bodyWithoutNullOrUndefined, config, headers);\n  }\n\n  sendRevokeRequest(configuration, body) {\n    const url = this.urlService.getRevocationEndpointUrl(configuration);\n    const headers = this.getHeaders();\n    return this.dataService.post(url, body, configuration, headers).pipe(retry(2), switchMap(response => {\n      this.loggerService.logDebug(configuration, 'revocation endpoint post response: ', response);\n      return of(response);\n    }), catchError(error => {\n      const errorMessage = `Revocation request failed`;\n      this.loggerService.logError(configuration, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  getHeaders() {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return headers;\n  }\n\n}\n\nLogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n  return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService));\n};\n\nLogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LogoffRevocationService,\n  factory: LogoffRevocationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LogoffRevocationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: CheckSessionService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: RedirectService\n    }];\n  }, null);\n})();\n\nclass OidcSecurityService {\n  constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationService, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService, authWellKnownService) {\n    this.checkSessionService = checkSessionService;\n    this.checkAuthService = checkAuthService;\n    this.userService = userService;\n    this.tokenHelperService = tokenHelperService;\n    this.configurationService = configurationService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.callbackService = callbackService;\n    this.logoffRevocationService = logoffRevocationService;\n    this.loginService = loginService;\n    this.refreshSessionService = refreshSessionService;\n    this.urlService = urlService;\n    this.authWellKnownService = authWellKnownService;\n  }\n  /**\r\n   * Provides information about the user after they have logged in.\r\n   *\r\n   * @returns Returns an object containing either the user data directly (single config) or\r\n   * the user data per config in case you are running with multiple configs\r\n   */\n\n\n  get userData$() {\n    return this.userService.userData$;\n  }\n  /**\r\n   * Emits each time an authorization event occurs.\r\n   *\r\n   * @returns Returns an object containing if you are authenticated or not.\r\n   * Single Config: true if config is authenticated, false if not.\r\n   * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n   *\r\n   * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n   */\n\n\n  get isAuthenticated$() {\n    return this.authStateService.authenticated$;\n  }\n  /**\r\n   * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n   * true.\r\n   */\n\n\n  get checkSessionChanged$() {\n    return this.checkSessionService.checkSessionChanged$;\n  }\n  /**\r\n   * Emits on a Security Token Service callback. The observable will never contain a value.\r\n   */\n\n\n  get stsCallback$() {\n    return this.callbackService.stsCallback$;\n  }\n\n  preloadAuthWellKnownDocument(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(concatMap(config => this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config)));\n  }\n  /**\r\n   * Returns the currently active OpenID configurations.\r\n   *\r\n   * @returns an array of OpenIdConfigurations.\r\n   */\n\n\n  getConfigurations() {\n    return this.configurationService.getAllConfigurations();\n  }\n  /**\r\n   * Returns a single active OpenIdConfiguration.\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n   */\n\n\n  getConfiguration(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId);\n  }\n  /**\r\n   * Returns the userData for a configuration\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being used\r\n   */\n\n\n  getUserData(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.userService.getUserDataFromStore(config)));\n  }\n  /**\r\n   * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An object `LoginResponse` containing all information about the login\r\n   */\n\n\n  checkAuth(url, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.checkAuthService.checkAuth(currentConfig, allConfigs, url)));\n  }\n  /**\r\n   * Starts the complete setup flow for multiple configurations.\r\n   * Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened in an array for each config which was provided\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n   * configured ones will be used to check.\r\n   *\r\n   * @returns An array of `LoginResponse` objects containing all information about the logins\r\n   */\n\n\n  checkAuthMultiple(url) {\n    return this.configurationService.getOpenIDConfigurations().pipe(concatMap(({\n      allConfigs\n    }) => this.checkAuthService.checkAuthMultiple(allConfigs, url)));\n  }\n  /**\r\n   * Provides information about the current authenticated state\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A boolean whether the config is authenticated or not.\r\n   */\n\n\n  isAuthenticated(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.isAuthenticated(config)));\n  }\n  /**\r\n   * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n   */\n\n\n  checkAuthIncludingServer(configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.checkAuthService.checkAuthIncludingServer(currentConfig, allConfigs)));\n  }\n  /**\r\n   * Returns the access token for the login scenario.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the access token.\r\n   */\n\n\n  getAccessToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getAccessToken(config)));\n  }\n  /**\r\n   * Returns the ID token for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the id token.\r\n   */\n\n\n  getIdToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getIdToken(config)));\n  }\n  /**\r\n   * Returns the refresh token, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the refresh token.\r\n   */\n\n\n  getRefreshToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getRefreshToken(config)));\n  }\n  /**\r\n   * Returns the authentication result, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A object with the authentication result\r\n   */\n\n\n  getAuthenticationResult(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getAuthenticationResult(config)));\n  }\n  /**\r\n   * Returns the payload from the ID token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the id token.\r\n   */\n\n\n  getPayloadFromIdToken(encode = false, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => {\n      const token = this.authStateService.getIdToken(config);\n      return this.tokenHelperService.getPayloadFromToken(token, encode, config);\n    }));\n  }\n  /**\r\n   * Returns the payload from the access token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the access token.\r\n   */\n\n\n  getPayloadFromAccessToken(encode = false, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => {\n      const token = this.authStateService.getAccessToken(config);\n      return this.tokenHelperService.getPayloadFromToken(token, encode, config);\n    }));\n  }\n  /**\r\n   * Sets a custom state for the authorize request.\r\n   *\r\n   * @param state The state to set.\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   */\n\n\n  setState(state, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.flowsDataService.setAuthStateControl(state, config)));\n  }\n  /**\r\n   * Gets the state value used for the authorize request.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The state value used for the authorize request.\r\n   */\n\n\n  getState(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.flowsDataService.getAuthStateControl(config)));\n  }\n  /**\r\n   * Redirects the user to the Security Token Service to begin the authentication process.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the the authentication request.\r\n   */\n\n\n  authorize(configId, authOptions) {\n    this.configurationService.getOpenIDConfiguration(configId).subscribe(config => this.loginService.login(config, authOptions));\n  }\n  /**\r\n   * Opens the Security Token Service in a new window to begin the authentication process.\r\n   *\r\n   * @param authOptions The custom options for the authentication request.\r\n   * @param popupOptions The configuration for the popup window.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  authorizeWithPopUp(authOptions, popupOptions, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.loginService.loginWithPopUp(currentConfig, allConfigs, authOptions, popupOptions)));\n  }\n  /**\r\n   * Manually refreshes the session.\r\n   *\r\n   * @param customParams Custom parameters to pass to the refresh request.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  forceRefreshSession(customParams, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.refreshSessionService.userForceRefreshSession(currentConfig, allConfigs, customParams)));\n  }\n  /**\r\n   * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n   * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n   * only the access token is revoked. Then the logout run.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the request.\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  logoffAndRevokeTokens(configId, logoutAuthOptions) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoffAndRevokeTokens(currentConfig, allConfigs, logoutAuthOptions)));\n  }\n  /**\r\n   * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n   * then only a local logout is performed.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions with custom parameters and/or an custom url handler\r\n   */\n\n\n  logoff(configId, logoutAuthOptions) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(concatMap(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoff(currentConfig, allConfigs, logoutAuthOptions)));\n  }\n  /**\r\n   * Logs the user out of the application without logging them out of the server.\r\n   * Use this method if you have _one_ config enabled.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   */\n\n\n  logoffLocal(configId) {\n    this.configurationService.getOpenIDConfigurations(configId).subscribe(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoffLocal(currentConfig, allConfigs));\n  }\n  /**\r\n   * Logs the user out of the application for all configs without logging them out of the server.\r\n   * Use this method if you have _multiple_ configs enabled.\r\n   */\n\n\n  logoffLocalMultiple() {\n    this.configurationService.getOpenIDConfigurations().subscribe(({\n      allConfigs\n    }) => this.logoffRevocationService.logoffLocalMultiple(allConfigs));\n  }\n  /**\r\n   * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param accessToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeAccessToken(accessToken, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(concatMap(config => this.logoffRevocationService.revokeAccessToken(config, accessToken)));\n  }\n  /**\r\n   * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param refreshToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeRefreshToken(refreshToken, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(concatMap(config => this.logoffRevocationService.revokeRefreshToken(config, refreshToken)));\n  }\n  /**\r\n   * Creates the end session URL which can be used to implement an alternate server logout.\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the end session url or null\r\n   */\n\n\n  getEndSessionUrl(customParams, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.urlService.getEndSessionUrl(config, customParams)));\n  }\n  /**\r\n   * Creates the authorize URL based on your flow\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the authorize URL or null\r\n   */\n\n\n  getAuthorizeUrl(customParams, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(concatMap(config => this.urlService.getAuthorizeUrl(config, customParams ? {\n      customParams\n    } : undefined)));\n  }\n\n}\n\nOidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n  return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService));\n};\n\nOidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcSecurityService,\n  factory: OidcSecurityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcSecurityService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: UserService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: CallbackService\n    }, {\n      type: LogoffRevocationService\n    }, {\n      type: LoginService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: UrlService\n    }, {\n      type: AuthWellKnownService\n    }];\n  }, null);\n})();\n\nclass DefaultSessionStorageService {\n  read(key) {\n    return sessionStorage.getItem(key);\n  }\n\n  write(key, value) {\n    sessionStorage.setItem(key, value);\n  }\n\n  remove(key) {\n    sessionStorage.removeItem(key);\n  }\n\n  clear() {\n    sessionStorage.clear();\n  }\n\n}\n\nDefaultSessionStorageService.ɵfac = function DefaultSessionStorageService_Factory(t) {\n  return new (t || DefaultSessionStorageService)();\n};\n\nDefaultSessionStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultSessionStorageService,\n  factory: DefaultSessionStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultSessionStorageService, [{\n    type: Injectable\n  }], null, null);\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\n\nclass AuthModule {\n  static forRoot(passedConfig) {\n    return {\n      ngModule: AuthModule,\n      providers: [// Make the PASSED_CONFIG available through injection\n      {\n        provide: PASSED_CONFIG,\n        useValue: passedConfig\n      }, // Create the loader: Either the one getting passed or a static one\n      (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || {\n        provide: StsConfigLoader,\n        useFactory: createStaticLoader,\n        deps: [PASSED_CONFIG]\n      }, ConfigurationService, PublicEventsService, FlowHelper, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JwkExtractor, JwkWindowCryptoService, JwtWindowCryptoService, CurrentUrlService, ClosestMatchingRouteService, DefaultSessionStorageService, BrowserStorageService, CryptoService, LoggerService, {\n        provide: AbstractSecurityStorage,\n        useClass: DefaultSessionStorageService\n      }, {\n        provide: AbstractLoggerService,\n        useClass: ConsoleLoggerService\n      }]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule, HttpClientModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, HttpClientModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nclass AutoLoginAllRoutesGuard {\n  constructor(autoLoginService, checkAuthService, loginService, configurationService, router) {\n    this.autoLoginService = autoLoginService;\n    this.checkAuthService = checkAuthService;\n    this.loginService = loginService;\n    this.configurationService = configurationService;\n    this.router = router;\n  }\n\n  canLoad() {\n    var _a, _b;\n\n    return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    return this.configurationService.getOpenIDConfiguration().pipe(switchMap(config => {\n      const allconfigs = this.configurationService.getAllConfigurations();\n      return this.checkAuthService.checkAuth(config, allconfigs).pipe(take(1), map(({\n        isAuthenticated\n      }) => {\n        if (isAuthenticated) {\n          this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n        }\n\n        if (!isAuthenticated) {\n          this.autoLoginService.saveRedirectRoute(config, url);\n          this.loginService.login(config);\n        }\n\n        return isAuthenticated;\n      }));\n    }));\n  }\n\n}\n\nAutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n  return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginAllRoutesGuard,\n  factory: AutoLoginAllRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginAllRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass AutoLoginPartialRoutesGuard {\n  constructor(autoLoginService, authStateService, loginService, configurationService, router) {\n    this.autoLoginService = autoLoginService;\n    this.authStateService = authStateService;\n    this.loginService = loginService;\n    this.configurationService = configurationService;\n    this.router = router;\n  }\n\n  canLoad() {\n    var _a, _b;\n\n    return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    return this.configurationService.getOpenIDConfiguration().pipe(map(configuration => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configuration);\n\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configuration);\n      }\n\n      if (!isAuthenticated) {\n        this.autoLoginService.saveRedirectRoute(configuration, url);\n        this.loginService.login(configuration);\n      }\n\n      return isAuthenticated;\n    }));\n  }\n\n}\n\nAutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n  return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginPartialRoutesGuard,\n  factory: AutoLoginPartialRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginPartialRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass AuthInterceptor {\n  constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {\n    this.authStateService = authStateService;\n    this.configurationService = configurationService;\n    this.loggerService = loggerService;\n    this.closestMatchingRouteService = closestMatchingRouteService;\n  }\n\n  intercept(req, next) {\n    return interceptRequest(req, next.handle, {\n      configurationService: this.configurationService,\n      authStateService: this.authStateService,\n      closestMatchingRouteService: this.closestMatchingRouteService,\n      loggerService: this.loggerService\n    });\n  }\n\n}\n\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n};\n\nAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: LoggerService\n    }, {\n      type: ClosestMatchingRouteService\n    }];\n  }, null);\n})();\n\nfunction authInterceptor() {\n  return (req, next) => {\n    return interceptRequest(req, next, {\n      configurationService: inject(ConfigurationService),\n      authStateService: inject(AuthStateService),\n      closestMatchingRouteService: inject(ClosestMatchingRouteService),\n      loggerService: inject(LoggerService)\n    });\n  };\n}\n\nfunction interceptRequest(req, next, deps) {\n  if (!deps.configurationService.hasAtLeastOneConfig()) {\n    return next(req);\n  }\n\n  const allConfigurations = deps.configurationService.getAllConfigurations();\n  const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n  const allRoutesConfiguredFlat = [].concat(...allRoutesConfigured);\n\n  if (allRoutesConfiguredFlat.length === 0) {\n    deps.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);\n    return next(req);\n  }\n\n  const {\n    matchingConfig,\n    matchingRoute\n  } = deps.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);\n\n  if (!matchingConfig) {\n    deps.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);\n    return next(req);\n  }\n\n  deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);\n  const token = deps.authStateService.getAccessToken(matchingConfig);\n\n  if (!token) {\n    deps.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n    return next(req);\n  }\n\n  deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n  req = req.clone({\n    headers: req.headers.set('Authorization', 'Bearer ' + token)\n  });\n  return next(req);\n} // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractLoggerService, AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, ConfigurationService, EventTypes, LogLevel, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, ValidationResult, authInterceptor, createStaticLoader };","map":{"version":3,"names":["DOCUMENT","isPlatformBrowser","CommonModule","i1","HttpHeaders","HttpParams","HttpErrorResponse","HttpResponse","HttpClientModule","i0","Injectable","Inject","PLATFORM_ID","InjectionToken","NgModule","inject","ReplaySubject","from","of","BehaviorSubject","Observable","throwError","timer","Subject","forkJoin","TimeoutError","map","mergeMap","tap","distinctUntilChanged","take","switchMap","retryWhen","catchError","retry","concatMap","finalize","timeout","base64url","i2","HttpBaseService","constructor","http","get","url","params","post","body","ɵfac","HttpClient","ɵprov","type","NGSW_CUSTOM_PARAM","DataService","httpClient","config","token","headers","prepareHeaders","prepareParams","headersParams","set","decodeURIComponent","ngswBypass","EventTypes","LogLevel","AbstractLoggerService","LoggerService","abstractLoggerService","logError","configuration","message","args","loggingIsTurnedOff","configId","messageToLog","isObject","JSON","stringify","length","logWarning","logLevelIsSet","currentLogLevelIsEqualOrSmallerThan","Warn","logDebug","Debug","logLevelToCompare","logLevel","undefined","None","possibleObject","Object","prototype","toString","call","AbstractSecurityStorage","BrowserStorageService","loggerService","abstractSecurityStorage","read","key","hasStorage","storedConfig","parse","write","value","remove","clear","Storage","StoragePersistenceService","browserStorageService","resetStorageFlowData","resetAuthStateInStorage","getAccessToken","getIdToken","_a","id_token","getRefreshToken","refreshToken","refresh_token","allowUnsafeReuseRefreshToken","getAuthenticationResult","PublicEventsService","notify","fireEvent","next","registerForEvents","asObservable","getVerifyAlg","alg","charAt","name","hash","includes","alg2kty","Error","getImportAlg","namedCurve","PARTS_OF_TOKEN","TokenHelperService","document","getTokenExpirationDate","dataIdToken","hasOwnProperty","Date","toUTCString","date","setUTCSeconds","exp","getSigningInputFromToken","encoded","tokenIsValid","header","getHeaderFromToken","payload","getPayloadFromToken","join","getPartOfToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","str","output","replace","decoded","defaultView","atob","Buffer","split","c","charCodeAt","slice","err","parts","Document","decorators","JwkExtractor","buildErrorName","extractJwk","keys","spec","throwOnEmpty","InvalidArgumentError","foundKeys","filter","k","kid","use","kty","NoMatchingKeysError","SeveralMatchingKeysError","CryptoService","doc","getCrypto","crypto","msCrypto","JwkWindowCryptoService","cryptoService","importVerificationKey","algorithm","subtle","importKey","verifyKey","verifyAlgorithm","cryptoKey","signature","signingInput","verify","TextEncoder","encode","JwtWindowCryptoService","generateCodeChallenge","codeVerifier","calcHash","pipe","challengeRaw","base64UrlEncode","generateAtHash","accessToken","tokenHash","substr","tokenHashBase64","btoa","valueToHash","msgBuffer","digest","hashBuffer","hashArray","Array","Uint8Array","toHashString","byteArray","e","String","fromCharCode","base64","TokenValidationService","tokenHelperService","jwkExtractor","jwkWindowCryptoService","jwtWindowCryptoService","keyAlgorithms","hasIdTokenExpired","offsetSeconds","validateIdTokenExpNotExpired","decodedIdToken","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","calculateNowWithOffset","tokenNotExpired","millisToMinutesAndSeconds","toLocaleTimeString","validateAccessTokenNotExpired","accessTokenExpiresAt","accessTokenExpirationValue","validateRequiredIdToken","validated","validateIdTokenIatMaxOffset","maxOffsetAllowedInSeconds","disableIatOffsetValidation","dateTimeIatIdToken","iat","nowInUtc","diff","maxOffsetAllowedInMilliseconds","validateIdTokenNonce","localNonce","ignoreNonceAfterRefresh","isFromRefreshToken","nonce","refreshTokenNoncePlaceholder","validateIdTokenIss","authWellKnownEndpointsIssuer","iss","validateIdTokenAud","aud","isArray","validateIdTokenAzpExistsIfMoreThanOneAud","azp","validateIdTokenAzpValid","clientId","validateStateFromHashCallback","state","localState","validateSignatureIdToken","idToken","jwtkeys","headerData","rawSignature","agent","navigator","userAgent","toLowerCase","indexOf","loose","isValid","validateIdTokenAtHash","atHash","idTokenAlg","sha","newHash","millis","minutes","Math","floor","seconds","toFixed","DEFAULT_AUTHRESULT","isAuthenticated","allConfigsAuthenticated","AuthStateService","storagePersistenceService","publicEventsService","tokenValidationService","authenticatedInternal$","authenticated$","setAuthenticatedAndFireEvent","allConfigs","composeAuthenticatedResult","setUnauthenticatedAndFireEvent","currentConfig","composeUnAuthenticatedResult","updateAndPublishAuthState","authenticationResult","NewAuthenticationResult","setAuthorizationData","authResult","persistAccessTokenExpirationTime","decodeURIComponentSafely","areAuthStorageTokensValid","hasIdTokenExpiredAndRenewCheckIsEnabled","hasAccessTokenExpiredIfExpiryExists","renewTimeBeforeTokenExpiresInSeconds","triggerRefreshWhenIdTokenExpired","disableIdTokenValidation","tokenToCheck","idTokenExpired","IdTokenExpired","accessTokenExpiresIn","accessTokenHasNotExpired","hasExpired","TokenExpired","hasAccessToken","hasIdToken","expires_in","accessTokenExpiryTime","checkAllConfigsIfTheyAreAuthenticated","every","x","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","createElement","id","title","style","display","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","CheckSessionService","iFrameService","eventService","zone","checkSessionReceived","lastIFrameRefresh","outstandingMessages","heartBeatInterval","iframeRefreshInterval","checkSessionChangedInternal$","checkSessionChanged$","isCheckSessionConfigured","startCheckSession","start","scheduledHeartBeatRunning","pollServerSession","stop","clearScheduledHeartBeat","serverStateChanged","getExistingIframe","init","now","authWellKnownEndPoints","existingIframe","getOrCreateIframe","checkSessionIframe","contentWindow","location","observer","onload","complete","pollServerSessionRecur","subscribe","sessionState","iframeOrigin","URL","origin","postMessage","runOutsideAngular","setTimeout","run","clearTimeout","messageHandler","existingIFrame","startsWith","source","data","CheckSessionReceived","bindMessageEventToIframe","iframeMessageEvent","bind","addEventListener","frame","NgZone","CurrentUrlService","getStateParamFromCurrentUrl","currentUrl","getCurrentUrl","parsedUrl","urlParams","URLSearchParams","search","stateFromUrl","ValidationResult","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","RandomService","createRandom","requiredLength","arr","getRandomValues","toHex","randomString","dec","characters","values","Uint32Array","i","FlowsDataService","randomService","createNonce","setNonce","getAuthStateControl","setAuthStateControl","authStateControl","getExistingOrCreateAuthStateControl","setSessionState","getCodeVerifier","createCodeVerifier","isCodeFlowInProgress","storageObject","getCodeFlowInProgressStorageEntry","setCodeFlowInProgress","resetCodeFlowInProgress","storageEntry","isSilentRenewRunning","silentRenewTimeoutInSeconds","getSilentRenewRunningStorageEntry","timeOutInMilliseconds","dateOfLaunchedProcessUtc","currentDateUtc","toISOString","elapsedTimeInMilliseconds","abs","isProbablyStuck","resetSilentRenewRunning","setSilentRenewRunning","FlowHelper","isCurrentFlowCodeFlow","currentFlowIs","isCurrentFlowAnyImplicitFlow","isCurrentFlowImplicitFlowWithAccessToken","isCurrentFlowImplicitFlowWithoutAccessToken","isCurrentFlowCodeFlowWithRefreshTokens","useRefreshToken","flowTypes","responseType","some","CALLBACK_PARAMS_TO_CHECK","AUTH0_ENDPOINT","UrlService","flowsDataService","flowHelper","getUrlParameter","urlToCheck","regex","RegExp","results","exec","isCallbackFromSts","getRefreshSessionSilentRenewUrl","customParams","createUrlCodeFlowWithSilentRenew","createUrlImplicitFlowWithSilentRenew","getAuthorizeParUrl","requestUri","authorizationEndpoint","urlParts","authorizationUrl","existingParams","createHttpParams","append","getAuthorizeUrl","authOptions","createUrlCodeFlowAuthorize","createUrlImplicitFlowAuthorize","getEndSessionEndpoint","endSessionEndpoint","getEndSessionUrl","customParamsEndSessionRequest","mergedParams","assign","createEndSessionUrl","createRevocationEndpointBodyAccessToken","getClientId","createRevocationEndpointBodyRefreshToken","getRevocationEndpointUrl","revocationEndpoint","revocationEndpointUrl","createBodyForCodeFlowCodeRequest","code","customTokenParams","disablePkce","appendCustomParams","silentRenewUrl","getSilentRenewUrl","redirectUrl","getRedirectUrl","createBodyForCodeFlowRefreshTokensRequest","customParamsRefresh","createBodyForParCodeFlowRequest","customParamsRequest","codeChallenge","scope","hdParam","customParamsAuthRequest","getPostLogoutRedirectUrl","postLogoutRedirectUri","idTokenHint","customParamsEndSession","isAuth0Endpoint","composeAuth0Endpoint","createAuthorizeUrl","prompt","customRequestParams","overWriteParam","getCodeChallenge","entries","fromString","encoder","authority","endsWith","postLogoutRedirectUrl","CodeFlowCallbackHandlerService","urlService","dataService","codeFlowCallback","initialCallbackContext","isRenewProcess","jwtKeys","validationResult","existingIdToken","codeFlowCodeRequest","callbackContext","isStateCorrect","authWellknownEndpoints","tokenEndpoint","bodyForCodeFlow","customParamsCodeRequest","response","session_state","error","handleRefreshRetry","errorMessage","errors","ProgressEvent","refreshTokenRetryInSeconds","DEFAULT_USERRESULT","userData","allUserData","UserService","oidcDataService","userDataInternal$","userData$","getAndPersistUserDataInStore","currentConfiguration","existingUserDataFromStorage","getUserDataFromStore","haveUserData","setUserDataToStore","renewUserInfoAfterTokenRenew","getUserDataOidcFlowAndSave","sub","publishUserDataIfExists","fireUserDataEvent","resetUserDataInStore","idTokenSub","getIdentityUserData","validateUserDataSubIdToken","userInfoEndpoint","userDataSub","passedUserData","composeSingleOrMultipleUserDataObject","UserDataChanged","hasManyConfigs","composeSingleUserDataResult","currentConfigIsToUpdate","alreadySavedUserData","ResetAuthDataService","authStateService","userService","resetAuthorizationData","ImplicitFlowCallbackHandlerService","resetAuthDataService","implicitFlowCallback","isRenewProcessData","substring","reduce","resultData","item","shift","SigninKeyDataService","getSigningKeys","jwksUri","handleErrorGetSigningKeys","errorResponse","errMsg","status","statusText","JWT_KEYS","HistoryJwtKeysCallbackHandlerService","signInKeyDataService","callbackHistoryAndResetJwtKeys","responseHasIdToken","historyCleanUpTurnedOn","resetBrowserHistory","handleResultErrorFromCallback","storeSigningKeys","storedJwtKeys","readSigningKeys","SecureTokenServerError","LoginRequired","historyCleanupOff","history","replaceState","pathname","UserCallbackHandlerService","callbackUser","autoUserInfo","publishAuthState","publishUnauthenticatedState","stateValidationResult","StateValidationResult","authResponseIsValid","at_hash","NotSet","EqualityService","isStringEqualOrNonOrderedArrayEqual","value1","value2","isNullOrUndefined","oneValueIsStringAndTheOtherIsArray","bothValuesAreStrings","arraysHaveEqualContent","areEqual","bothValuesAreArrays","arraysStrictEqual","bothValuesAreObjects","valueIsString","valueIsObject","arr1","arr2","v","val","StateValidationService","equalityService","getValidatedStateResult","validateState","toReturn","StatesDoNotMatch","handleUnsuccessfulValidation","access_token","Ok","isInRefreshTokenFlow","issValidationOff","maxIdTokenIatOffsetAllowedInSeconds","isSignatureIdTokenValid","SignatureFailed","authNonce","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","issuer","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","IncorrectAzp","isIdTokenAfterRefreshTokenRequestValid","IncorrectIdTokenClaimsAfterRefresh","validateDefault","handleSuccessfulValidation","idTokenHeader","valid","IncorrectAtHash","newIdToken","disableRefreshIdTokenAuthTimeValidation","auth_time","autoCleanStateAfterAuthentication","StateValidationCallbackHandlerService","stateValidationService","callbackStateValidation","publishUnauthorizedState","RefreshSessionCallbackHandlerService","refreshSessionWithRefreshTokens","stateData","RefreshTokenCallbackHandlerService","refreshTokensRequestTokens","FlowsService","codeFlowCallbackHandlerService","implicitFlowCallbackHandlerService","historyJwtKeysCallbackHandlerService","userHandlerService","stateValidationCallbackHandlerService","refreshSessionCallbackHandlerService","refreshTokenCallbackHandlerService","processCodeFlowCallback","processSilentRenewCodeFlowCallback","firstContext","processImplicitFlowCallback","processRefreshToken","IntervalService","runTokenValidationRunning","isTokenValidationRunning","stopPeriodicTokenCheck","unsubscribe","startPeriodicTokenCheck","repeatAfterSeconds","millisecondsDelayBetweenTokenCheck","subscriber","intervalId","setInterval","clearInterval","providedIn","ImplicitFlowCallbackService","flowsService","router","intervalService","authenticatedImplicitFlowCallback","triggerAuthorizationResultEvent","postLoginRoute","unauthorizedRoute","navigateByUrl","Router","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","SilentRenewService","implicitFlowCallbackService","refreshSessionWithIFrameCompletedInternal$","refreshSessionWithIFrameCompleted$","isSilentRenewConfigured","silentRenew","codeFlowCallbackSilentRenewIframe","silentRenewEventHandler","detail","callback$","isCodeFlow","CodeFlowCallbackService","authenticatedCallbackWithCode","CallbackService","codeFlowCallbackService","stsCallbackInternal$","stsCallback$","isCallback","handleCallbackAndFireEvents","currentCallbackUrl","WELL_KNOWN_SUFFIX","AuthWellKnownDataService","getWellKnownEndPointsForConfig","authWellknownEndpointUrl","getWellKnownDocument","wellKnownEndpoints","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspectionEndpoint","introspection_endpoint","parEndpoint","pushed_authorization_request_endpoint","wellKnownEndpoint","AuthWellKnownService","storeWellKnownEndpoints","mappedWellKnownEndpoints","queryAndStoreAuthWellKnownEndPoints","alreadySavedWellKnownEndpoints","ConfigLoadingFailed","RefreshSessionIframeService","silentRenewService","rendererFactory","renderer","createRenderer","refreshSessionWithIframe","sendAuthorizeRequestUsingSilentRenew","initSilentRenewRequest","onLoadHandler","removeEventListener","instanceId","random","initDestroyHandler","listen","renewDestroyHandler","dispatchEvent","CustomEvent","RendererFactory2","RefreshSessionRefreshTokenService","refreshTokenFailed","MAX_RETRY_ATTEMPTS","RefreshSessionService","authWellKnownService","refreshSessionIframeService","refreshSessionRefreshTokenService","userForceRefreshSession","extraCustomParams","persistCustomParams","forceRefreshSession","customParamsRefreshTokenRequest","startRefreshSession","timeOutTime","timeoutRetryStrategy","_","_b","shouldBeExecuted","errorAttempts","scalingDuration","currentAttempt","DEFAULT_CONFIG","usePushedAuthorisationRequests","forbiddenRoute","tokenRefreshInSeconds","POSITIVE_VALIDATION_RESULT","messages","level","ensureAuthority","passedConfig","ensureClientId","createIdentifierToCheck","arrayHasDuplicates","array","Set","size","ensureNoDuplicatedConfigsRule","passedConfigs","allIdentifiers","someAreNull","hasDuplicates","ensureRedirectRule","ensureSilentRenewUrlWhenNoRefreshTokenUsed","usesSilentRenew","usesRefreshToken","hasSilentRenewUrl","useOfflineScopeWithSilentRenew","hasRefreshToken","hasSilentRenew","hasOfflineScope","allRules","allMultipleConfigRules","ConfigValidationService","validateConfigs","validateConfigsInternal","validateConfig","validateConfigInternal","allRulesToUse","allValidationResults","rule","overallErrorCount","forEach","errorCount","processValidationResultsAndGetErrorCount","allMessages","allErrorMessages","getAllMessagesOfType","allWarnings","acc","concat","PlatformProvider","platformId","isBrowser","OpenIdConfigLoader","StsConfigLoader","StsConfigStaticLoader","loadConfigs","StsConfigHttpLoader","configs$","singleConfigOrArray","ConfigurationService","configValidationService","platformProvider","loader","configsInternal","getAllConfigurations","getOpenIDConfiguration","configsAlreadySaved","getConfig","getOpenIDConfigurations","prepareAndSaveConfigs","allPreparedConfigs","hasAtLeastOneConfig","saveConfig","readyConfig","createUniqueIds","allHandleConfigs$","handleConfig","usedConfig","prepareConfig","configWithAuthWellKnown","enhanceConfigWithWellKnownEndpoint","ConfigLoaded","alreadyExistingAuthWellKnownEndpoints","passedAuthWellKnownEndpoints","openIdConfigurationInternal","setSpecialCases","PeriodicallyTokenCheckService","configurationService","startTokenValidationPeriodically","configsWithSilentRenewEnabled","getConfigsWithSilentRenewEnabled","refreshTimeInSeconds","getSmallestRefreshTimeFromConfigs","periodicallyCheck$","objectWithConfigIdsAndRefreshEvent","getRefreshEvent","objectWithConfigIds","shouldStartRefreshEvent","shouldStartPeriodicallyCheckForConfig","refreshEvent$","createRefreshEventForConfig","SilentRenewStarted","refreshEventWithErrorHandler$","SilentRenewFailed","prev","curr","isCodeFlowinProgress","userDataFromStore","accessTokenHasExpired","PopUpService","STORAGE_IDENTIFIER","resultInternal$","result$","windowInternal","currentWindowIsPopUp","opener","isCurrentlyInPopup","canAccessSessionStorage","mainWindowHasPopupOpen","currentWindowIsPopup","openPopUp","popupOptions","optionsToPass","getOptions","popUp","open","listener","event","cleanUp","userClosed","receivedUrl","handle","closed","sendMessageToMainWindow","href","sendMessage","close","popupDefaultOptions","width","height","left","top","options","screenLeft","outerWidth","screenTop","outerHeight","cookieEnabled","STORAGE_KEY","AutoLoginService","storageService","checkSavedRedirectRouteAndNavigate","savedRouteForRedirect","getStoredRedirectRoute","deleteStoredRedirectRoute","saveRedirectRoute","CheckAuthService","checkSessionService","currentUrlService","callbackService","refreshSessionService","periodicallyTokenCheckService","popupService","autoLoginService","checkAuth","CheckingAuth","stateParamFromUrl","getConfigurationWithUrlState","checkAuthWithConfig","checkAuthMultiple","composeMultipleLoginResults","configs","allChecks$","checkAuthIncludingServer","loginResponse","loginResponseAfterRefreshSession","startCheckSessionAndValidation","CheckingAuthFinished","CheckingAuthFinishedWithError","configurations","storedState","activeConfig","allOtherConfigs","currentConfigResult","allOtherConfigResults","ClosestMatchingRouteService","getConfigIdForClosestMatchingRoute","route","secureRoutes","configuredRoute","matchingRoute","matchingConfig","ConsoleLoggerService","console","warn","debug","ResponseTypeValidationService","hasConfigValidResponseType","RedirectService","redirectTo","ParService","postParRequest","authWellKnownEndpoints","expiresIn","request_uri","ParLoginService","responseTypeValidationService","redirectService","checkAuthService","parService","loginPar","urlHandler","loginWithPopUpPar","PopUpLoginService","loginWithPopUpStandard","authUrl","StandardLoginService","loginStandard","LoginService","parLoginService","popUpLoginService","standardLoginService","login","loginWithPopUp","isAlreadyInPopUp","removeNullAndUndefinedValues","obj","copy","LogoffRevocationService","logoff","logoutAuthOptions","endSessionUrl","logoffInternal","logoffLocal","logoffLocalMultiple","logoffAndRevokeTokens","revokeRefreshToken","revokeAccessToken","accessTok","sendRevokeRequest","refreshTok","logoffMethod","logout_hint","ui_locales","getHeaders","id_token_hint","client_id","post_logout_redirect_uri","bodyWithoutNullOrUndefined","OidcSecurityService","logoffRevocationService","loginService","isAuthenticated$","preloadAuthWellKnownDocument","getConfigurations","getConfiguration","getUserData","getPayloadFromIdToken","getPayloadFromAccessToken","setState","getState","authorize","authorizeWithPopUp","DefaultSessionStorageService","sessionStorage","getItem","setItem","removeItem","createStaticLoader","PASSED_CONFIG","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","useClass","ɵmod","ɵinj","imports","declarations","exports","AutoLoginAllRoutesGuard","canLoad","getCurrentNavigation","extractedUrl","canActivate","canActivateChild","allconfigs","AutoLoginPartialRoutesGuard","AuthInterceptor","closestMatchingRouteService","intercept","req","interceptRequest","authInterceptor","allConfigurations","allRoutesConfigured","allRoutesConfiguredFlat","clone"],"sources":["C:/projects/IdServer/SPA/ClientApp/node_modules/angular-auth-oidc-client/fesm2015/angular-auth-oidc-client.mjs"],"sourcesContent":["import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, NgModule, inject } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, Observable, throwError, timer, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, take, switchMap, retryWhen, catchError, retry, concatMap, finalize, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    get(url, params) {\r\n        return this.http.get(url, params);\r\n    }\r\n    post(url, body, params) {\r\n        return this.http.post(url, body, params);\r\n    }\r\n}\r\nHttpBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HttpBaseService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHttpBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HttpBaseService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HttpBaseService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\r\nclass DataService {\r\n    constructor(httpClient) {\r\n        this.httpClient = httpClient;\r\n    }\r\n    get(url, config, token) {\r\n        const headers = this.prepareHeaders(token);\r\n        const params = this.prepareParams(config);\r\n        return this.httpClient.get(url, {\r\n            headers,\r\n            params,\r\n        });\r\n    }\r\n    post(url, body, config, headersParams) {\r\n        const headers = headersParams || this.prepareHeaders();\r\n        const params = this.prepareParams(config);\r\n        return this.httpClient.post(url, body, { headers, params });\r\n    }\r\n    prepareHeaders(token) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        if (!!token) {\r\n            headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n        }\r\n        return headers;\r\n    }\r\n    prepareParams(config) {\r\n        let params = new HttpParams();\r\n        const { ngswBypass } = config;\r\n        if (ngswBypass) {\r\n            params = params.set(NGSW_CUSTOM_PARAM, '');\r\n        }\r\n        return params;\r\n    }\r\n}\r\nDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DataService, deps: [{ token: HttpBaseService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: HttpBaseService }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar EventTypes;\r\n(function (EventTypes) {\r\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\r\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\r\n    EventTypes[EventTypes[\"CheckingAuth\"] = 1] = \"CheckingAuth\";\r\n    EventTypes[EventTypes[\"CheckingAuthFinished\"] = 2] = \"CheckingAuthFinished\";\r\n    EventTypes[EventTypes[\"CheckingAuthFinishedWithError\"] = 3] = \"CheckingAuthFinishedWithError\";\r\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 4] = \"ConfigLoadingFailed\";\r\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 5] = \"CheckSessionReceived\";\r\n    EventTypes[EventTypes[\"UserDataChanged\"] = 6] = \"UserDataChanged\";\r\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 7] = \"NewAuthenticationResult\";\r\n    EventTypes[EventTypes[\"TokenExpired\"] = 8] = \"TokenExpired\";\r\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 9] = \"IdTokenExpired\";\r\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 10] = \"SilentRenewStarted\";\r\n    EventTypes[EventTypes[\"SilentRenewFailed\"] = 11] = \"SilentRenewFailed\";\r\n})(EventTypes || (EventTypes = {}));\n\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n})(LogLevel || (LogLevel = {}));\n\n/**\r\n * Implement this class-interface to create a custom logger service.\r\n */\r\nclass AbstractLoggerService {\r\n}\r\nAbstractLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractLoggerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractLoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractLoggerService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass LoggerService {\r\n    constructor(abstractLoggerService) {\r\n        this.abstractLoggerService = abstractLoggerService;\r\n    }\r\n    logError(configuration, message, ...args) {\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    logWarning(configuration, message, ...args) {\r\n        if (!this.logLevelIsSet(configuration)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Warn)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    logDebug(configuration, message, ...args) {\r\n        if (!this.logLevelIsSet(configuration)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Debug)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    currentLogLevelIsEqualOrSmallerThan(configuration, logLevelToCompare) {\r\n        const { logLevel } = configuration || {};\r\n        return logLevel <= logLevelToCompare;\r\n    }\r\n    logLevelIsSet(configuration) {\r\n        const { logLevel } = configuration || {};\r\n        if (logLevel === null) {\r\n            return false;\r\n        }\r\n        if (logLevel === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    loggingIsTurnedOff(configuration) {\r\n        const { logLevel } = configuration || {};\r\n        return logLevel === LogLevel.None;\r\n    }\r\n    isObject(possibleObject) {\r\n        return Object.prototype.toString.call(possibleObject) === '[object Object]';\r\n    }\r\n}\r\nLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoggerService, deps: [{ token: AbstractLoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoggerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AbstractLoggerService }]; } });\n\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\nclass AbstractSecurityStorage {\r\n}\r\nAbstractSecurityStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractSecurityStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractSecurityStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractSecurityStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AbstractSecurityStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass BrowserStorageService {\r\n    constructor(loggerService, abstractSecurityStorage) {\r\n        this.loggerService = loggerService;\r\n        this.abstractSecurityStorage = abstractSecurityStorage;\r\n    }\r\n    read(key, configuration) {\r\n        const { configId } = configuration;\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to read '${key}' but Storage was undefined`);\r\n            return null;\r\n        }\r\n        const storedConfig = this.abstractSecurityStorage.read(configId);\r\n        if (!storedConfig) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storedConfig);\r\n    }\r\n    write(value, configuration) {\r\n        const { configId } = configuration;\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        value = value || null;\r\n        this.abstractSecurityStorage.write(configId, JSON.stringify(value));\r\n        return true;\r\n    }\r\n    remove(key, configuration) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to remove '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        // const storage = this.getStorage(configuration);\r\n        // if (!storage) {\r\n        //   this.loggerService.logDebug(configuration, `Wanted to write '${key}' but Storage was falsy`);\r\n        //   return false;\r\n        // }\r\n        this.abstractSecurityStorage.remove(key);\r\n        return true;\r\n    }\r\n    // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\r\n    clear(configuration) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        // const storage = this.getStorage(configuration);\r\n        // if (!storage) {\r\n        //   this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\r\n        //   return false;\r\n        // }\r\n        this.abstractSecurityStorage.clear();\r\n        return true;\r\n    }\r\n    hasStorage() {\r\n        return typeof Storage !== 'undefined';\r\n    }\r\n}\r\nBrowserStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: BrowserStorageService, deps: [{ token: LoggerService }, { token: AbstractSecurityStorage }], target: i0.ɵɵFactoryTarget.Injectable });\r\nBrowserStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: BrowserStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: BrowserStorageService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AbstractSecurityStorage }]; } });\n\nclass StoragePersistenceService {\r\n    constructor(browserStorageService) {\r\n        this.browserStorageService = browserStorageService;\r\n    }\r\n    read(key, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        return storedConfig[key];\r\n    }\r\n    write(key, value, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        storedConfig[key] = value;\r\n        return this.browserStorageService.write(storedConfig, config);\r\n    }\r\n    remove(key, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        delete storedConfig[key];\r\n        this.browserStorageService.write(storedConfig, config);\r\n    }\r\n    clear(config) {\r\n        this.browserStorageService.clear(config);\r\n    }\r\n    resetStorageFlowData(config) {\r\n        this.remove('session_state', config);\r\n        this.remove('storageSilentRenewRunning', config);\r\n        this.remove('storageCodeFlowInProgress', config);\r\n        this.remove('codeVerifier', config);\r\n        this.remove('userData', config);\r\n        this.remove('storageCustomParamsAuthRequest', config);\r\n        this.remove('access_token_expires_at', config);\r\n        this.remove('storageCustomParamsRefresh', config);\r\n        this.remove('storageCustomParamsEndSession', config);\r\n        this.remove('reusable_refresh_token', config);\r\n    }\r\n    resetAuthStateInStorage(config) {\r\n        this.remove('authzData', config);\r\n        this.remove('reusable_refresh_token', config);\r\n        this.remove('authnResult', config);\r\n    }\r\n    getAccessToken(config) {\r\n        return this.read('authzData', config);\r\n    }\r\n    getIdToken(config) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.id_token;\r\n    }\r\n    getRefreshToken(config) {\r\n        var _a;\r\n        let refreshToken = (_a = this.read('authnResult', config)) === null || _a === void 0 ? void 0 : _a.refresh_token;\r\n        if (!refreshToken && config.allowUnsafeReuseRefreshToken) {\r\n            return this.read('reusable_refresh_token', config);\r\n        }\r\n        return refreshToken;\r\n    }\r\n    getAuthenticationResult(config) {\r\n        return this.read('authnResult', config);\r\n    }\r\n}\r\nStoragePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StoragePersistenceService, deps: [{ token: BrowserStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStoragePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StoragePersistenceService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StoragePersistenceService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: BrowserStorageService }]; } });\n\nclass PublicEventsService {\r\n    constructor() {\r\n        this.notify = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\r\n    fireEvent(type, value) {\r\n        this.notify.next({ type, value });\r\n    }\r\n    /**\r\n     * Wires up the event notification observable.\r\n     */\r\n    registerForEvents() {\r\n        return this.notify.asObservable();\r\n    }\r\n}\r\nPublicEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PublicEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPublicEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PublicEventsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PublicEventsService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nfunction getVerifyAlg(alg) {\r\n    switch (alg.charAt(0)) {\r\n        case 'R':\r\n            return {\r\n                name: 'RSASSA-PKCS1-v1_5',\r\n                hash: 'SHA-256',\r\n            };\r\n        case 'E':\r\n            if (alg.includes('256')) {\r\n                return {\r\n                    name: 'ECDSA',\r\n                    hash: 'SHA-256',\r\n                };\r\n            }\r\n            else if (alg.includes('384')) {\r\n                return {\r\n                    name: 'ECDSA',\r\n                    hash: 'SHA-384',\r\n                };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction alg2kty(alg) {\r\n    switch (alg.charAt(0)) {\r\n        case 'R':\r\n            return 'RSA';\r\n        case 'E':\r\n            return 'EC';\r\n        default:\r\n            throw new Error('Cannot infer kty from alg: ' + alg);\r\n    }\r\n}\r\nfunction getImportAlg(alg) {\r\n    switch (alg.charAt(0)) {\r\n        case 'R':\r\n            if (alg.includes('256')) {\r\n                return {\r\n                    name: 'RSASSA-PKCS1-v1_5',\r\n                    hash: 'SHA-256',\r\n                };\r\n            }\r\n            else if (alg.includes('384')) {\r\n                return {\r\n                    name: 'RSASSA-PKCS1-v1_5',\r\n                    hash: 'SHA-384',\r\n                };\r\n            }\r\n            else if (alg.includes('512')) {\r\n                return {\r\n                    name: 'RSASSA-PKCS1-v1_5',\r\n                    hash: 'SHA-512',\r\n                };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        case 'E':\r\n            if (alg.includes('256')) {\r\n                return {\r\n                    name: 'ECDSA',\r\n                    namedCurve: 'P-256',\r\n                };\r\n            }\r\n            else if (alg.includes('384')) {\r\n                return {\r\n                    name: 'ECDSA',\r\n                    namedCurve: 'P-384',\r\n                };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        default:\r\n            return null;\r\n    }\r\n}\n\nconst PARTS_OF_TOKEN = 3;\r\nclass TokenHelperService {\r\n    constructor(loggerService, document) {\r\n        this.loggerService = loggerService;\r\n        this.document = document;\r\n    }\r\n    getTokenExpirationDate(dataIdToken) {\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\r\n            return new Date(new Date().toUTCString());\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n        return date;\r\n    }\r\n    getSigningInputFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return '';\r\n        }\r\n        const header = this.getHeaderFromToken(token, encoded, configuration);\r\n        const payload = this.getPayloadFromToken(token, encoded, configuration);\r\n        return [header, payload].join('.');\r\n    }\r\n    getHeaderFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n    getPayloadFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n    getSignatureFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n    getPartOfToken(token, index, encoded) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n        const decoded = typeof this.document.defaultView !== 'undefined'\r\n            ? this.document.defaultView.atob(output)\r\n            : Buffer.from(output, 'base64').toString('binary');\r\n        try {\r\n            // Going backwards: from byte stream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded\r\n                .split('')\r\n                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        }\r\n        catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n    tokenIsValid(token, configuration) {\r\n        if (!token) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n        if (!token.includes('.')) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    extractPartOfToken(token, index) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\nTokenHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenHelperService, deps: [{ token: LoggerService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenHelperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: LoggerService }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass JwkExtractor {\r\n    static buildErrorName(name) {\r\n        return JwkExtractor.name + ': ' + name;\r\n    }\r\n    extractJwk(keys, spec, throwOnEmpty = true) {\r\n        if (0 === keys.length) {\r\n            throw JwkExtractor.InvalidArgumentError;\r\n        }\r\n        let foundKeys = keys\r\n            .filter((k) => (spec === null || spec === void 0 ? void 0 : spec.kid) ? k['kid'] === spec.kid : true)\r\n            .filter((k) => (spec === null || spec === void 0 ? void 0 : spec.use) ? k['use'] === spec.use : true)\r\n            .filter((k) => (spec === null || spec === void 0 ? void 0 : spec.kty) ? k['kty'] === spec.kty : true);\r\n        if (foundKeys.length === 0 && throwOnEmpty) {\r\n            throw JwkExtractor.NoMatchingKeysError;\r\n        }\r\n        if (foundKeys.length > 1 && (null === spec || undefined === spec)) {\r\n            throw JwkExtractor.SeveralMatchingKeysError;\r\n        }\r\n        return foundKeys;\r\n    }\r\n}\r\nJwkExtractor.InvalidArgumentError = {\r\n    name: JwkExtractor.buildErrorName('InvalidArgumentError'),\r\n    message: 'Array of keys was empty. Unable to extract'\r\n};\r\nJwkExtractor.NoMatchingKeysError = {\r\n    name: JwkExtractor.buildErrorName('NoMatchingKeysError'),\r\n    message: 'No key found matching the spec'\r\n};\r\nJwkExtractor.SeveralMatchingKeysError = {\r\n    name: JwkExtractor.buildErrorName('SeveralMatchingKeysError'),\r\n    message: 'More than one key found. Please use spec to filter'\r\n};\r\nJwkExtractor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkExtractor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwkExtractor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkExtractor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkExtractor, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass CryptoService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getCrypto() {\r\n        // support for IE,  (window.crypto || window.msCrypto)\r\n        return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\r\n    }\r\n}\r\nCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CryptoService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass JwkWindowCryptoService {\r\n    constructor(cryptoService) {\r\n        this.cryptoService = cryptoService;\r\n    }\r\n    importVerificationKey(key, algorithm) {\r\n        return this.cryptoService.getCrypto().subtle.importKey('jwk', key, algorithm, false, ['verify']);\r\n    }\r\n    verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput) {\r\n        return this.cryptoService.getCrypto().subtle.verify(verifyAlgorithm, cryptoKey, signature, new TextEncoder().encode(signingInput));\r\n    }\r\n}\r\nJwkWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkWindowCryptoService, deps: [{ token: CryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwkWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkWindowCryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwkWindowCryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }]; } });\n\nclass JwtWindowCryptoService {\r\n    constructor(cryptoService) {\r\n        this.cryptoService = cryptoService;\r\n    }\r\n    generateCodeChallenge(codeVerifier) {\r\n        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => this.base64UrlEncode(challengeRaw)));\r\n    }\r\n    generateAtHash(accessToken, algorithm) {\r\n        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {\r\n            let substr = tokenHash.substr(0, tokenHash.length / 2);\r\n            const tokenHashBase64 = btoa(substr);\r\n            return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n        }));\r\n    }\r\n    calcHash(valueToHash, algorithm = 'SHA-256') {\r\n        const msgBuffer = new TextEncoder().encode(valueToHash);\r\n        return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {\r\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n            return this.toHashString(hashArray);\r\n        }));\r\n    }\r\n    toHashString(byteArray) {\r\n        let result = '';\r\n        for (let e of byteArray) {\r\n            result += String.fromCharCode(e);\r\n        }\r\n        return result;\r\n    }\r\n    base64UrlEncode(str) {\r\n        const base64 = btoa(str);\r\n        return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n    }\r\n}\r\nJwtWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwtWindowCryptoService, deps: [{ token: CryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwtWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwtWindowCryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: JwtWindowCryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }]; } });\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\r\n// Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\r\n// in the ID Token.\r\nclass TokenValidationService {\r\n    constructor(tokenHelperService, loggerService, jwkExtractor, jwkWindowCryptoService, jwtWindowCryptoService, document) {\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.jwkExtractor = jwkExtractor;\r\n        this.jwkWindowCryptoService = jwkWindowCryptoService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n        this.document = document;\r\n        this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    hasIdTokenExpired(token, configuration, offsetSeconds) {\r\n        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);\r\n        return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds);\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds) {\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        return tokenNotExpired;\r\n    }\r\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {\r\n        // value is optional, so if it does not exist, then it has not expired\r\n        if (!accessTokenExpiresAt) {\r\n            return true;\r\n        }\r\n        offsetSeconds = offsetSeconds || 0;\r\n        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\r\n        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\r\n        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        return tokenNotExpired;\r\n    }\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\r\n    // https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\r\n    // audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\r\n    // the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\r\n    // 1970- 01 - 01T00: 00: 00Z as measured\r\n    // in UTC until the date/ time.\r\n    validateRequiredIdToken(dataIdToken, configuration) {\r\n        let validated = true;\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');\r\n        }\r\n        return validated;\r\n    }\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {\r\n        if (disableIatOffsetValidation) {\r\n            return true;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\r\n            return false;\r\n        }\r\n        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\r\n        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\r\n        const nowInUtc = new Date(new Date().toUTCString());\r\n        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\r\n        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\r\n        this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\r\n        if (diff > 0) {\r\n            return diff < maxOffsetAllowedInMilliseconds;\r\n        }\r\n        return -diff < maxOffsetAllowedInMilliseconds;\r\n    }\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and KeyCloak does send it.\r\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {\r\n        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {\r\n        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                dataIdToken.iss +\r\n                ' authWellKnownEndpoints issuer:' +\r\n                authWellKnownEndpointsIssuer);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validateIdTokenAud(dataIdToken, aud, configuration) {\r\n        if (Array.isArray(dataIdToken.aud)) {\r\n            const result = dataIdToken.aud.includes(aud);\r\n            if (!result) {\r\n                this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\r\n        if (!dataIdToken) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n    validateIdTokenAzpValid(dataIdToken, clientId) {\r\n        if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\r\n            return true;\r\n        }\r\n        if (dataIdToken.azp === clientId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    validateStateFromHashCallback(state, localState, configuration) {\r\n        if (state !== localState) {\r\n            this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validateSignatureIdToken(idToken, jwtkeys, configuration) {\r\n        if (!idToken) {\r\n            return of(true);\r\n        }\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return of(false);\r\n        }\r\n        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);\r\n        if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\r\n            this.loggerService.logWarning(configuration, 'id token has no header data');\r\n            return of(false);\r\n        }\r\n        const kid = headerData.kid;\r\n        let alg = headerData.alg;\r\n        let keys = jwtkeys.keys;\r\n        let foundKeys;\r\n        let key;\r\n        if (!this.keyAlgorithms.includes(alg)) {\r\n            this.loggerService.logWarning(configuration, 'alg not supported', alg);\r\n            return of(false);\r\n        }\r\n        const kty = alg2kty(alg);\r\n        const use = 'sig';\r\n        try {\r\n            foundKeys = kid\r\n                ? this.jwkExtractor.extractJwk(keys, { kid, kty, use }, false)\r\n                : this.jwkExtractor.extractJwk(keys, { kty, use }, false);\r\n            if (foundKeys.length === 0) {\r\n                foundKeys = kid ? this.jwkExtractor.extractJwk(keys, { kid, kty }) : this.jwkExtractor.extractJwk(keys, { kty });\r\n            }\r\n            key = foundKeys[0];\r\n        }\r\n        catch (e) {\r\n            this.loggerService.logError(configuration, e);\r\n            return of(false);\r\n        }\r\n        const algorithm = getImportAlg(alg);\r\n        const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);\r\n        const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);\r\n        const agent = this.document.defaultView.navigator.userAgent.toLowerCase();\r\n        if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\r\n            key.alg = '';\r\n        }\r\n        return from(this.jwkWindowCryptoService.importVerificationKey(key, algorithm)).pipe(mergeMap((cryptoKey) => {\r\n            const signature = base64url.parse(rawSignature, { loose: true });\r\n            const verifyAlgorithm = getVerifyAlg(alg);\r\n            return from(this.jwkWindowCryptoService.verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput));\r\n        }), tap((isValid) => {\r\n            if (!isValid) {\r\n                this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');\r\n            }\r\n        }));\r\n    }\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n    ////    return true;\r\n    //// }\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {\r\n        this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash);\r\n        // 'sha256' 'sha384' 'sha512'\r\n        let sha = 'SHA-256';\r\n        if (idTokenAlg.includes('384')) {\r\n            sha = 'SHA-384';\r\n        }\r\n        else if (idTokenAlg.includes('512')) {\r\n            sha = 'SHA-512';\r\n        }\r\n        return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap((hash) => {\r\n            this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);\r\n            if (hash === atHash) {\r\n                return of(true); // isValid;\r\n            }\r\n            else {\r\n                return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map((newHash) => {\r\n                    this.loggerService.logDebug(configuration, '-gen access--' + hash);\r\n                    return newHash === atHash;\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    millisToMinutesAndSeconds(millis) {\r\n        const minutes = Math.floor(millis / 60000);\r\n        const seconds = ((millis % 60000) / 1000).toFixed(0);\r\n        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\r\n    }\r\n    calculateNowWithOffset(offsetSeconds) {\r\n        return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n    }\r\n}\r\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\r\nTokenValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JwkExtractor }, { token: JwkWindowCryptoService }, { token: JwtWindowCryptoService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: TokenValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: TokenHelperService }, { type: LoggerService }, { type: JwkExtractor }, { type: JwkWindowCryptoService }, { type: JwtWindowCryptoService }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nconst DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };\r\nclass AuthStateService {\r\n    constructor(storagePersistenceService, loggerService, publicEventsService, tokenValidationService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\r\n    }\r\n    get authenticated$() {\r\n        return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n    setAuthenticatedAndFireEvent(allConfigs) {\r\n        const result = this.composeAuthenticatedResult(allConfigs);\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    setUnauthenticatedAndFireEvent(currentConfig, allConfigs) {\r\n        this.storagePersistenceService.resetAuthStateInStorage(currentConfig);\r\n        const result = this.composeUnAuthenticatedResult(allConfigs);\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    updateAndPublishAuthState(authenticationResult) {\r\n        this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\r\n    }\r\n    setAuthorizationData(accessToken, authResult, currentConfig, allConfigs) {\r\n        this.loggerService.logDebug(currentConfig, `storing the accessToken '${accessToken}'`);\r\n        this.storagePersistenceService.write('authzData', accessToken, currentConfig);\r\n        this.persistAccessTokenExpirationTime(authResult, currentConfig);\r\n        this.setAuthenticatedAndFireEvent(allConfigs);\r\n    }\r\n    getAccessToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getAccessToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getIdToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getIdToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getRefreshToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getRefreshToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getAuthenticationResult(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        return this.storagePersistenceService.getAuthenticationResult(configuration);\r\n    }\r\n    areAuthStorageTokensValid(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return false;\r\n        }\r\n        if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configuration)) {\r\n            this.loggerService.logDebug(configuration, 'persisted idToken is expired');\r\n            return false;\r\n        }\r\n        if (this.hasAccessTokenExpiredIfExpiryExists(configuration)) {\r\n            this.loggerService.logDebug(configuration, 'persisted accessToken is expired');\r\n            return false;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'persisted idToken and accessToken are valid');\r\n        return true;\r\n    }\r\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configuration) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds, triggerRefreshWhenIdTokenExpired, disableIdTokenValidation } = configuration;\r\n        if (!triggerRefreshWhenIdTokenExpired || disableIdTokenValidation) {\r\n            return false;\r\n        }\r\n        const tokenToCheck = this.storagePersistenceService.getIdToken(configuration);\r\n        const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configuration, renewTimeBeforeTokenExpiresInSeconds);\r\n        if (idTokenExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\r\n        }\r\n        return idTokenExpired;\r\n    }\r\n    hasAccessTokenExpiredIfExpiryExists(configuration) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds } = configuration;\r\n        const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configuration);\r\n        const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configuration, renewTimeBeforeTokenExpiresInSeconds);\r\n        const hasExpired = !accessTokenHasNotExpired;\r\n        if (hasExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\r\n        }\r\n        return hasExpired;\r\n    }\r\n    isAuthenticated(configuration) {\r\n        const hasAccessToken = !!this.storagePersistenceService.getAccessToken(configuration);\r\n        const hasIdToken = !!this.storagePersistenceService.getIdToken(configuration);\r\n        return hasAccessToken && hasIdToken;\r\n    }\r\n    decodeURIComponentSafely(token) {\r\n        if (token) {\r\n            return decodeURIComponent(token);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    persistAccessTokenExpirationTime(authResult, configuration) {\r\n        if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\r\n            const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\r\n            this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configuration);\r\n        }\r\n    }\r\n    composeAuthenticatedResult(allConfigs) {\r\n        if (allConfigs.length === 1) {\r\n            const { configId } = allConfigs[0];\r\n            return { isAuthenticated: true, allConfigsAuthenticated: [{ configId, isAuthenticated: true }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\r\n    }\r\n    composeUnAuthenticatedResult(allConfigs) {\r\n        if (allConfigs.length === 1) {\r\n            const { configId } = allConfigs[0];\r\n            return { isAuthenticated: false, allConfigsAuthenticated: [{ configId, isAuthenticated: false }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\r\n    }\r\n    checkAllConfigsIfTheyAreAuthenticated(allConfigs) {\r\n        const allConfigsAuthenticated = allConfigs.map((config) => ({\r\n            configId: config.configId,\r\n            isAuthenticated: this.isAuthenticated(config),\r\n        }));\r\n        const isAuthenticated = allConfigsAuthenticated.every((x) => !!x.isAuthenticated);\r\n        return { allConfigsAuthenticated, isAuthenticated };\r\n    }\r\n}\r\nAuthStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: TokenValidationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthStateService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthStateService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: TokenValidationService }]; } });\n\nclass IFrameService {\r\n    constructor(document, loggerService) {\r\n        this.document = document;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getExistingIFrame(identifier) {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n    addIFrameToWindowBody(identifier, config) {\r\n        const sessionIframe = this.document.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        sessionIframe.title = identifier;\r\n        this.loggerService.logDebug(config, sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        this.document.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n    getIFrameFromParentWindow(identifier) {\r\n        try {\r\n            const iFrameElement = this.document.defaultView.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    getIFrameFromWindow(identifier) {\r\n        const iFrameElement = this.document.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n    isIFrameElement(element) {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\nIFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IFrameService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IFrameService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IFrameService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }];\r\n    } });\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\nclass CheckSessionService {\r\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, zone, document) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.iFrameService = iFrameService;\r\n        this.eventService = eventService;\r\n        this.zone = zone;\r\n        this.document = document;\r\n        this.checkSessionReceived = false;\r\n        this.lastIFrameRefresh = 0;\r\n        this.outstandingMessages = 0;\r\n        this.heartBeatInterval = 3000;\r\n        this.iframeRefreshInterval = 60000;\r\n        this.checkSessionChangedInternal$ = new BehaviorSubject(false);\r\n    }\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionChangedInternal$.asObservable();\r\n    }\r\n    isCheckSessionConfigured(configuration) {\r\n        const { startCheckSession } = configuration;\r\n        return startCheckSession;\r\n    }\r\n    start(configuration) {\r\n        if (!!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        const { clientId } = configuration;\r\n        this.pollServerSession(clientId, configuration);\r\n    }\r\n    stop() {\r\n        if (!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        this.clearScheduledHeartBeat();\r\n        this.checkSessionReceived = false;\r\n    }\r\n    serverStateChanged(configuration) {\r\n        const { startCheckSession } = configuration;\r\n        return startCheckSession && this.checkSessionReceived;\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n    }\r\n    init(configuration) {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return of(undefined);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configuration, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return of();\r\n        }\r\n        const existingIframe = this.getOrCreateIframe(configuration);\r\n        const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\r\n        if (checkSessionIframe) {\r\n            existingIframe.contentWindow.location.replace(checkSessionIframe);\r\n        }\r\n        else {\r\n            this.loggerService.logWarning(configuration, 'CheckSession - init check session: checkSessionIframe is not configured to run');\r\n        }\r\n        return new Observable((observer) => {\r\n            existingIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next();\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n    pollServerSession(clientId, configuration) {\r\n        this.outstandingMessages = 0;\r\n        const pollServerSessionRecur = () => {\r\n            this.init(configuration)\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                var _a;\r\n                const existingIframe = this.getExistingIframe();\r\n                if (existingIframe && clientId) {\r\n                    this.loggerService.logDebug(configuration, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                    const sessionState = this.storagePersistenceService.read('session_state', configuration);\r\n                    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n                    if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\r\n                        const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\r\n                        this.outstandingMessages++;\r\n                        existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\r\n                    }\r\n                    else {\r\n                        this.loggerService.logDebug(configuration, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\r\n                        this.checkSessionChangedInternal$.next(true);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configuration, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\r\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                }\r\n                // after sending three messages with no response, fail.\r\n                if (this.outstandingMessages > 3) {\r\n                    this.loggerService.logError(configuration, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\r\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\r\n                }\r\n                this.zone.runOutsideAngular(() => {\r\n                    this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\r\n                });\r\n            });\r\n        };\r\n        pollServerSessionRecur();\r\n    }\r\n    clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeatRunning);\r\n        this.scheduledHeartBeatRunning = null;\r\n    }\r\n    messageHandler(configuration, e) {\r\n        var _a;\r\n        const existingIFrame = this.getExistingIframe();\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\r\n        this.outstandingMessages = 0;\r\n        if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning(configuration, 'CheckSession - error from check session messageHandler');\r\n            }\r\n            else if (e.data === 'changed') {\r\n                this.loggerService.logDebug(configuration, `CheckSession - ${e} from check session messageHandler`);\r\n                this.checkSessionReceived = true;\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.checkSessionChangedInternal$.next(true);\r\n            }\r\n            else {\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.loggerService.logDebug(configuration, `CheckSession - ${e.data} from check session messageHandler`);\r\n            }\r\n        }\r\n    }\r\n    bindMessageEventToIframe(configuration) {\r\n        const iframeMessageEvent = this.messageHandler.bind(this, configuration);\r\n        this.document.defaultView.addEventListener('message', iframeMessageEvent, false);\r\n    }\r\n    getOrCreateIframe(configuration) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configuration);\r\n            this.bindMessageEventToIframe(configuration);\r\n            return frame;\r\n        }\r\n        return existingIframe;\r\n    }\r\n}\r\nCheckSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckSessionService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckSessionService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: i0.NgZone }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass CurrentUrlService {\r\n    constructor(document) {\r\n        this.document = document;\r\n    }\r\n    getStateParamFromCurrentUrl(url) {\r\n        const currentUrl = url || this.getCurrentUrl();\r\n        const parsedUrl = new URL(currentUrl);\r\n        const urlParams = new URLSearchParams(parsedUrl.search);\r\n        const stateFromUrl = urlParams.get('state');\r\n        return stateFromUrl;\r\n    }\r\n    getCurrentUrl() {\r\n        return this.document.defaultView.location.toString();\r\n    }\r\n}\r\nCurrentUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CurrentUrlService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCurrentUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CurrentUrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CurrentUrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nvar ValidationResult;\r\n(function (ValidationResult) {\r\n    ValidationResult[\"NotSet\"] = \"NotSet\";\r\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\r\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\r\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\r\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\r\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\r\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\r\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\r\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\r\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\r\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\r\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\r\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\r\n    ValidationResult[\"Ok\"] = \"Ok\";\r\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\r\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\r\n})(ValidationResult || (ValidationResult = {}));\n\nclass UriEncoder {\r\n    encodeKey(key) {\r\n        return encodeURIComponent(key);\r\n    }\r\n    encodeValue(value) {\r\n        return encodeURIComponent(value);\r\n    }\r\n    decodeKey(key) {\r\n        return decodeURIComponent(key);\r\n    }\r\n    decodeValue(value) {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\n\nclass RandomService {\r\n    constructor(cryptoService, loggerService) {\r\n        this.cryptoService = cryptoService;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createRandom(requiredLength, configuration) {\r\n        if (requiredLength <= 0) {\r\n            return '';\r\n        }\r\n        if (requiredLength > 0 && requiredLength < 7) {\r\n            this.loggerService.logWarning(configuration, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\r\n            requiredLength = 10;\r\n        }\r\n        const length = requiredLength - 6;\r\n        const arr = new Uint8Array(Math.floor(length / 2));\r\n        const crypto = this.cryptoService.getCrypto();\r\n        if (crypto) {\r\n            crypto.getRandomValues(arr);\r\n        }\r\n        return Array.from(arr, this.toHex).join('') + this.randomString(7);\r\n    }\r\n    toHex(dec) {\r\n        return ('0' + dec.toString(16)).substr(-2);\r\n    }\r\n    randomString(length) {\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const values = new Uint32Array(length);\r\n        const crypto = this.cryptoService.getCrypto();\r\n        if (crypto) {\r\n            crypto.getRandomValues(values);\r\n            for (let i = 0; i < length; i++) {\r\n                result += characters[values[i] % characters.length];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nRandomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RandomService, deps: [{ token: CryptoService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRandomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RandomService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RandomService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }, { type: LoggerService }]; } });\n\nclass FlowsDataService {\r\n    constructor(storagePersistenceService, randomService, loggerService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.randomService = randomService;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createNonce(configuration) {\r\n        const nonce = this.randomService.createRandom(40, configuration);\r\n        this.loggerService.logDebug(configuration, 'Nonce created. nonce:' + nonce);\r\n        this.setNonce(nonce, configuration);\r\n        return nonce;\r\n    }\r\n    setNonce(nonce, configuration) {\r\n        this.storagePersistenceService.write('authNonce', nonce, configuration);\r\n    }\r\n    getAuthStateControl(configuration) {\r\n        return this.storagePersistenceService.read('authStateControl', configuration);\r\n    }\r\n    setAuthStateControl(authStateControl, configuration) {\r\n        return this.storagePersistenceService.write('authStateControl', authStateControl, configuration);\r\n    }\r\n    getExistingOrCreateAuthStateControl(configuration) {\r\n        let state = this.storagePersistenceService.read('authStateControl', configuration);\r\n        if (!state) {\r\n            state = this.randomService.createRandom(40, configuration);\r\n            this.storagePersistenceService.write('authStateControl', state, configuration);\r\n        }\r\n        return state;\r\n    }\r\n    setSessionState(sessionState, configuration) {\r\n        this.storagePersistenceService.write('session_state', sessionState, configuration);\r\n    }\r\n    resetStorageFlowData(configuration) {\r\n        this.storagePersistenceService.resetStorageFlowData(configuration);\r\n    }\r\n    getCodeVerifier(configuration) {\r\n        return this.storagePersistenceService.read('codeVerifier', configuration);\r\n    }\r\n    createCodeVerifier(configuration) {\r\n        const codeVerifier = this.randomService.createRandom(67, configuration);\r\n        this.storagePersistenceService.write('codeVerifier', codeVerifier, configuration);\r\n        return codeVerifier;\r\n    }\r\n    isCodeFlowInProgress(configuration) {\r\n        const storageObject = this.getCodeFlowInProgressStorageEntry(configuration);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        return storageObject.state === 'in progress';\r\n    }\r\n    setCodeFlowInProgress(configuration) {\r\n        const storageObject = {\r\n            state: 'in progress',\r\n        };\r\n        this.storagePersistenceService.write('storageCodeFlowInProgress', JSON.stringify(storageObject), configuration);\r\n    }\r\n    resetCodeFlowInProgress(configuration) {\r\n        this.storagePersistenceService.write('storageCodeFlowInProgress', '', configuration);\r\n    }\r\n    getCodeFlowInProgressStorageEntry(configuration) {\r\n        const storageEntry = this.storagePersistenceService.read('storageCodeFlowInProgress', configuration);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n    isSilentRenewRunning(configuration) {\r\n        const { configId, silentRenewTimeoutInSeconds } = configuration;\r\n        const storageObject = this.getSilentRenewRunningStorageEntry(configuration);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\r\n        const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\r\n        const currentDateUtc = Date.parse(new Date().toISOString());\r\n        const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\r\n        const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\r\n        if (isProbablyStuck) {\r\n            this.loggerService.logDebug(configuration, 'silent renew process is probably stuck, state will be reset.', configId);\r\n            this.resetSilentRenewRunning(configuration);\r\n            return false;\r\n        }\r\n        return storageObject.state === 'running';\r\n    }\r\n    setSilentRenewRunning(configuration) {\r\n        const storageObject = {\r\n            state: 'running',\r\n            dateOfLaunchedProcessUtc: new Date().toISOString(),\r\n        };\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configuration);\r\n    }\r\n    resetSilentRenewRunning(configuration) {\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', '', configuration);\r\n    }\r\n    getSilentRenewRunningStorageEntry(configuration) {\r\n        const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configuration);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n}\r\nFlowsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: LoggerService }]; } });\n\nclass FlowHelper {\r\n    isCurrentFlowCodeFlow(configuration) {\r\n        return this.currentFlowIs('code', configuration);\r\n    }\r\n    isCurrentFlowAnyImplicitFlow(configuration) {\r\n        return this.isCurrentFlowImplicitFlowWithAccessToken(configuration) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configuration);\r\n    }\r\n    isCurrentFlowCodeFlowWithRefreshTokens(configuration) {\r\n        const { useRefreshToken } = configuration;\r\n        if (this.isCurrentFlowCodeFlow(configuration) && useRefreshToken) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCurrentFlowImplicitFlowWithAccessToken(configuration) {\r\n        return this.currentFlowIs('id_token token', configuration);\r\n    }\r\n    currentFlowIs(flowTypes, configuration) {\r\n        const { responseType } = configuration;\r\n        if (Array.isArray(flowTypes)) {\r\n            return flowTypes.some((x) => responseType === x);\r\n        }\r\n        return responseType === flowTypes;\r\n    }\r\n    isCurrentFlowImplicitFlowWithoutAccessToken(configuration) {\r\n        return this.currentFlowIs('id_token', configuration);\r\n    }\r\n}\r\nFlowHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowHelper });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowHelper, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\r\nconst AUTH0_ENDPOINT = 'auth0.com';\r\nclass UrlService {\r\n    constructor(loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n    }\r\n    getUrlParameter(urlToCheck, name) {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n        if (!name) {\r\n            return '';\r\n        }\r\n        name = name.replace(/[[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&#]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n    isCallbackFromSts(currentUrl) {\r\n        return CALLBACK_PARAMS_TO_CHECK.some((x) => !!this.getUrlParameter(currentUrl, x));\r\n    }\r\n    getRefreshSessionSilentRenewUrl(config, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            return this.createUrlCodeFlowWithSilentRenew(config, customParams);\r\n        }\r\n        return of(this.createUrlImplicitFlowWithSilentRenew(config, customParams) || '');\r\n    }\r\n    getAuthorizeParUrl(requestUri, configuration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }\r\n        const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('request_uri', requestUri);\r\n        params = params.append('client_id', clientId);\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    getAuthorizeUrl(config, authOptions) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            return this.createUrlCodeFlowAuthorize(config, authOptions);\r\n        }\r\n        return of(this.createUrlImplicitFlowAuthorize(config, authOptions) || '');\r\n    }\r\n    getEndSessionEndpoint(configuration) {\r\n        var _a;\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\r\n        if (!endSessionEndpoint) {\r\n            return {\r\n                url: '',\r\n                existingParams: '',\r\n            };\r\n        }\r\n        const urlParts = endSessionEndpoint.split('?');\r\n        const url = urlParts[0];\r\n        const existingParams = (_a = urlParts[1]) !== null && _a !== void 0 ? _a : '';\r\n        return {\r\n            url,\r\n            existingParams,\r\n        };\r\n    }\r\n    getEndSessionUrl(configuration, customParams) {\r\n        const idToken = this.storagePersistenceService.getIdToken(configuration);\r\n        const { customParamsEndSessionRequest } = configuration;\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\r\n        return this.createEndSessionUrl(idToken, configuration, mergedParams);\r\n    }\r\n    createRevocationEndpointBodyAccessToken(token, configuration) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'access_token');\r\n        return params.toString();\r\n    }\r\n    createRevocationEndpointBodyRefreshToken(token, configuration) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'refresh_token');\r\n        return params.toString();\r\n    }\r\n    getRevocationEndpointUrl(configuration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\r\n        if (!revocationEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = revocationEndpoint.split('?');\r\n        const revocationEndpointUrl = urlParts[0];\r\n        return revocationEndpointUrl;\r\n    }\r\n    createBodyForCodeFlowCodeRequest(code, configuration, customTokenParams) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'authorization_code');\r\n        params = params.set('client_id', clientId);\r\n        if (!configuration.disablePkce) {\r\n            const codeVerifier = this.flowsDataService.getCodeVerifier(configuration);\r\n            if (!codeVerifier) {\r\n                this.loggerService.logError(configuration, `CodeVerifier is not set `, codeVerifier);\r\n                return null;\r\n            }\r\n            params = params.set('code_verifier', codeVerifier);\r\n        }\r\n        params = params.set('code', code);\r\n        if (customTokenParams) {\r\n            params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\r\n        }\r\n        const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n        if (this.flowsDataService.isSilentRenewRunning(configuration) && silentRenewUrl) {\r\n            params = params.set('redirect_uri', silentRenewUrl);\r\n            return params.toString();\r\n        }\r\n        const redirectUrl = this.getRedirectUrl(configuration);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        params = params.set('redirect_uri', redirectUrl);\r\n        return params.toString();\r\n    }\r\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configuration, customParamsRefresh) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'refresh_token');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('refresh_token', refreshToken);\r\n        if (customParamsRefresh) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createBodyForParCodeFlowRequest(configuration, customParamsRequest) {\r\n        const redirectUrl = this.getRedirectUrl(configuration);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = configuration;\r\n            let params = this.createHttpParams('');\r\n            params = params.set('client_id', clientId);\r\n            params = params.append('redirect_uri', redirectUrl);\r\n            params = params.append('response_type', responseType);\r\n            params = params.append('scope', scope);\r\n            params = params.append('nonce', nonce);\r\n            params = params.append('state', state);\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n            if (hdParam) {\r\n                params = params.append('hd', hdParam);\r\n            }\r\n            if (customParamsAuthRequest) {\r\n                params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\r\n            }\r\n            if (customParamsRequest) {\r\n                params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\r\n            }\r\n            return params.toString();\r\n        }));\r\n    }\r\n    getPostLogoutRedirectUrl(configuration) {\r\n        const { postLogoutRedirectUri } = configuration;\r\n        if (!postLogoutRedirectUri) {\r\n            this.loggerService.logError(configuration, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\r\n            return null;\r\n        }\r\n        return postLogoutRedirectUri;\r\n    }\r\n    createEndSessionUrl(idTokenHint, configuration, customParamsEndSession) {\r\n        // Auth0 needs a special logout url\r\n        // See https://auth0.com/docs/api/authentication#logout\r\n        if (this.isAuth0Endpoint(configuration)) {\r\n            return this.composeAuth0Endpoint(configuration);\r\n        }\r\n        const { url, existingParams } = this.getEndSessionEndpoint(configuration);\r\n        if (!url) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams(existingParams);\r\n        if (!!idTokenHint) {\r\n            params = params.set('id_token_hint', idTokenHint);\r\n        }\r\n        const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configuration);\r\n        if (postLogoutRedirectUri) {\r\n            params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\r\n        }\r\n        if (customParamsEndSession) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\r\n        }\r\n        return `${url}?${params}`;\r\n    }\r\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configuration, prompt, customRequestParams) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        if (!responseType) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add responseType because it was: `, responseType);\r\n            return null;\r\n        }\r\n        if (!scope) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add scope because it was: `, scope);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configuration) && codeChallenge !== null) {\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\r\n        if (Object.keys(mergedParams).length > 0) {\r\n            params = this.appendCustomParams(Object.assign({}, mergedParams), params);\r\n        }\r\n        if (prompt) {\r\n            params = this.overWriteParam(params, 'prompt', prompt);\r\n        }\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    createUrlImplicitFlowWithSilentRenew(configuration, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ', state);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configuration, 'none', customParams);\r\n        }\r\n        this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowWithSilentRenew(configuration, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n            if (!silentRenewUrl) {\r\n                return '';\r\n            }\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n            if (authWellKnownEndPoints) {\r\n                return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configuration, 'none', customParams);\r\n            }\r\n            this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }));\r\n    }\r\n    createUrlImplicitFlowAuthorize(configuration, authOptions) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configuration, authOptions);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (authWellKnownEndPoints) {\r\n            const { customParams } = authOptions || {};\r\n            return this.createAuthorizeUrl('', redirectUrl, nonce, state, configuration, null, customParams);\r\n        }\r\n        this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowAuthorize(config, authOptions) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\r\n        const nonce = this.flowsDataService.createNonce(config);\r\n        this.loggerService.logDebug(config, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(config, authOptions);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        return this.getCodeChallenge(config).pipe(map((codeChallenge) => {\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n            if (authWellKnownEndPoints) {\r\n                const { customParams } = authOptions || {};\r\n                return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, config, null, customParams);\r\n            }\r\n            this.loggerService.logError(config, 'authWellKnownEndpoints is undefined');\r\n            return '';\r\n        }));\r\n    }\r\n    getCodeChallenge(config) {\r\n        if (config.disablePkce) {\r\n            return of(null);\r\n        }\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(config);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier);\r\n    }\r\n    getRedirectUrl(configuration, authOptions) {\r\n        let { redirectUrl } = configuration;\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.redirectUrl) {\r\n            // override by redirectUrl from authOptions\r\n            redirectUrl = authOptions.redirectUrl;\r\n        }\r\n        if (!redirectUrl) {\r\n            this.loggerService.logError(configuration, `could not get redirectUrl, was: `, redirectUrl);\r\n            return null;\r\n        }\r\n        return redirectUrl;\r\n    }\r\n    getSilentRenewUrl(configuration) {\r\n        const { silentRenewUrl } = configuration;\r\n        if (!silentRenewUrl) {\r\n            this.loggerService.logError(configuration, `could not get silentRenewUrl, was: `, silentRenewUrl);\r\n            return null;\r\n        }\r\n        return silentRenewUrl;\r\n    }\r\n    getClientId(configuration) {\r\n        const { clientId } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `could not get clientId, was: `, clientId);\r\n            return null;\r\n        }\r\n        return clientId;\r\n    }\r\n    appendCustomParams(customParams, params) {\r\n        for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\r\n            params = params.append(key, value.toString());\r\n        }\r\n        return params;\r\n    }\r\n    overWriteParam(params, key, value) {\r\n        return params.set(key, value);\r\n    }\r\n    createHttpParams(existingParams) {\r\n        existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\r\n        const params = new HttpParams({\r\n            fromString: existingParams,\r\n            encoder: new UriEncoder(),\r\n        });\r\n        return params;\r\n    }\r\n    isAuth0Endpoint(configuration) {\r\n        const { authority } = configuration;\r\n        if (!authority) {\r\n            return false;\r\n        }\r\n        return authority.endsWith(AUTH0_ENDPOINT);\r\n    }\r\n    composeAuth0Endpoint(configuration) {\r\n        // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\r\n        const { authority, clientId } = configuration;\r\n        const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configuration);\r\n        return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\r\n    }\r\n}\r\nUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlService, deps: [{ token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JwtWindowCryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JwtWindowCryptoService }]; } });\n\nclass CodeFlowCallbackHandlerService {\r\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, storagePersistenceService, dataService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.dataService = dataService;\r\n    }\r\n    // STEP 1 Code Flow\r\n    codeFlowCallback(urlToCheck, config) {\r\n        const code = this.urlService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\r\n        if (!state) {\r\n            this.loggerService.logDebug(config, 'no state in url');\r\n            return throwError(() => new Error('no state in url'));\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug(config, 'no code in url');\r\n            return throwError(() => new Error('no code in url'));\r\n        }\r\n        this.loggerService.logDebug(config, 'running validation for callback', urlToCheck);\r\n        const initialCallbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: false,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(initialCallbackContext);\r\n    }\r\n    // STEP 2 Code Flow //  Code Flow Silent Renew starts here\r\n    codeFlowCodeRequest(callbackContext, config) {\r\n        const authStateControl = this.flowsDataService.getAuthStateControl(config);\r\n        const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, config);\r\n        if (!isStateCorrect) {\r\n            return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\r\n        }\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, config, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\r\n        return this.dataService.post(tokenEndpoint, bodyForCodeFlow, config, headers).pipe(switchMap((response) => {\r\n            let authResult = Object.assign(Object.assign({}, response), { state: callbackContext.state, session_state: callbackContext.sessionState });\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, config)), catchError((error) => {\r\n            const { authority } = config;\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(config, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, config) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = config;\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(config, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => error);\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: StoragePersistenceService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: StoragePersistenceService }, { type: DataService }]; } });\n\nconst DEFAULT_USERRESULT = { userData: null, allUserData: [] };\r\nclass UserService {\r\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper) {\r\n        this.oidcDataService = oidcDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.eventService = eventService;\r\n        this.loggerService = loggerService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.flowHelper = flowHelper;\r\n        this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\r\n    }\r\n    get userData$() {\r\n        return this.userDataInternal$.asObservable();\r\n    }\r\n    getAndPersistUserDataInStore(currentConfiguration, allConfigs, isRenewProcess = false, idToken, decodedIdToken) {\r\n        idToken = idToken || this.storagePersistenceService.getIdToken(currentConfiguration);\r\n        decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, currentConfiguration);\r\n        const existingUserDataFromStorage = this.getUserDataFromStore(currentConfiguration);\r\n        const haveUserData = !!existingUserDataFromStorage;\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(currentConfiguration);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(currentConfiguration);\r\n        const accessToken = this.storagePersistenceService.getAccessToken(currentConfiguration);\r\n        if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\r\n            this.loggerService.logDebug(currentConfiguration, `authCallback idToken flow with accessToken ${accessToken}`);\r\n            this.setUserDataToStore(decodedIdToken, currentConfiguration, allConfigs);\r\n            return of(decodedIdToken);\r\n        }\r\n        const { renewUserInfoAfterTokenRenew } = currentConfiguration;\r\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\r\n            return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, currentConfiguration, allConfigs).pipe(switchMap((userData) => {\r\n                this.loggerService.logDebug(currentConfiguration, 'Received user data: ', userData);\r\n                if (!!userData) {\r\n                    this.loggerService.logDebug(currentConfiguration, 'accessToken: ', accessToken);\r\n                    return of(userData);\r\n                }\r\n                else {\r\n                    return throwError(() => new Error('Received no user data, request failed'));\r\n                }\r\n            }));\r\n        }\r\n        return of(existingUserDataFromStorage);\r\n    }\r\n    getUserDataFromStore(currentConfiguration) {\r\n        return this.storagePersistenceService.read('userData', currentConfiguration) || null;\r\n    }\r\n    publishUserDataIfExists(currentConfiguration, allConfigs) {\r\n        const userData = this.getUserDataFromStore(currentConfiguration);\r\n        if (userData) {\r\n            this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\r\n        }\r\n    }\r\n    setUserDataToStore(userData, currentConfiguration, allConfigs) {\r\n        this.storagePersistenceService.write('userData', userData, currentConfiguration);\r\n        this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\r\n    }\r\n    resetUserDataInStore(currentConfiguration, allConfigs) {\r\n        this.storagePersistenceService.remove('userData', currentConfiguration);\r\n        this.fireUserDataEvent(currentConfiguration, allConfigs, null);\r\n    }\r\n    getUserDataOidcFlowAndSave(idTokenSub, currentConfiguration, allConfigs) {\r\n        return this.getIdentityUserData(currentConfiguration).pipe(map((data) => {\r\n            if (this.validateUserDataSubIdToken(currentConfiguration, idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\r\n                this.setUserDataToStore(data, currentConfiguration, allConfigs);\r\n                return data;\r\n            }\r\n            else {\r\n                // something went wrong, user data sub does not match that from id_token\r\n                this.loggerService.logWarning(currentConfiguration, `User data sub does not match sub in id_token, resetting`);\r\n                this.resetUserDataInStore(currentConfiguration, allConfigs);\r\n                return null;\r\n            }\r\n        }));\r\n    }\r\n    getIdentityUserData(currentConfiguration) {\r\n        const token = this.storagePersistenceService.getAccessToken(currentConfiguration);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(currentConfiguration, 'init check session: authWellKnownEndpoints is undefined');\r\n            return throwError(() => new Error('authWellKnownEndpoints is undefined'));\r\n        }\r\n        const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\r\n        if (!userInfoEndpoint) {\r\n            this.loggerService.logError(currentConfiguration, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\r\n            return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\r\n        }\r\n        return this.oidcDataService.get(userInfoEndpoint, currentConfiguration, token).pipe(retry(2));\r\n    }\r\n    validateUserDataSubIdToken(currentConfiguration, idTokenSub, userDataSub) {\r\n        if (!idTokenSub) {\r\n            return false;\r\n        }\r\n        if (!userDataSub) {\r\n            return false;\r\n        }\r\n        if (idTokenSub !== userDataSub) {\r\n            this.loggerService.logDebug(currentConfiguration, 'validateUserDataSubIdToken failed', idTokenSub, userDataSub);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    fireUserDataEvent(currentConfiguration, allConfigs, passedUserData) {\r\n        const userData = this.composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData);\r\n        this.userDataInternal$.next(userData);\r\n        const { configId } = currentConfiguration;\r\n        this.eventService.fireEvent(EventTypes.UserDataChanged, { configId, userData: passedUserData });\r\n    }\r\n    composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData) {\r\n        const hasManyConfigs = allConfigs.length > 1;\r\n        if (!hasManyConfigs) {\r\n            const { configId } = currentConfiguration;\r\n            return this.composeSingleUserDataResult(configId, passedUserData);\r\n        }\r\n        const allUserData = allConfigs.map((config) => {\r\n            const { configId } = currentConfiguration;\r\n            if (this.currentConfigIsToUpdate(configId, config)) {\r\n                return { configId: config.configId, userData: passedUserData };\r\n            }\r\n            const alreadySavedUserData = this.storagePersistenceService.read('userData', config) || null;\r\n            return { configId: config.configId, userData: alreadySavedUserData };\r\n        });\r\n        return {\r\n            userData: null,\r\n            allUserData,\r\n        };\r\n    }\r\n    composeSingleUserDataResult(configId, userData) {\r\n        return {\r\n            userData,\r\n            allUserData: [{ configId, userData }],\r\n        };\r\n    }\r\n    currentConfigIsToUpdate(configId, config) {\r\n        return config.configId === configId;\r\n    }\r\n}\r\nUserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }]; } });\n\nclass ResetAuthDataService {\r\n    constructor(authStateService, flowsDataService, userService, loggerService) {\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n    }\r\n    resetAuthorizationData(currentConfiguration, allConfigs) {\r\n        this.userService.resetUserDataInStore(currentConfiguration, allConfigs);\r\n        this.flowsDataService.resetStorageFlowData(currentConfiguration);\r\n        this.authStateService.setUnauthenticatedAndFireEvent(currentConfiguration, allConfigs);\r\n        this.loggerService.logDebug(currentConfiguration, 'Local Login information cleaned up and event fired');\r\n    }\r\n}\r\nResetAuthDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResetAuthDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResetAuthDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResetAuthDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: LoggerService }]; } });\n\nclass ImplicitFlowCallbackHandlerService {\r\n    constructor(resetAuthDataService, loggerService, flowsDataService, document) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.document = document;\r\n    }\r\n    // STEP 1 Code Flow\r\n    // STEP 1 Implicit Flow\r\n    implicitFlowCallback(config, allConfigs, hash) {\r\n        const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(config);\r\n        this.loggerService.logDebug(config, 'BEGIN callback, no auth data');\r\n        if (!isRenewProcessData) {\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        }\r\n        hash = hash || this.document.location.hash.substring(1);\r\n        const authResult = hash.split('&').reduce((resultData, item) => {\r\n            const parts = item.split('=');\r\n            resultData[parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        const callbackContext = {\r\n            code: null,\r\n            refreshToken: null,\r\n            state: null,\r\n            sessionState: null,\r\n            authResult,\r\n            isRenewProcess: isRenewProcessData,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(callbackContext);\r\n    }\r\n}\r\nImplicitFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass SigninKeyDataService {\r\n    constructor(storagePersistenceService, loggerService, dataService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n    }\r\n    getSigningKeys(currentConfiguration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\r\n        const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\r\n        if (!jwksUri) {\r\n            const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\r\n            this.loggerService.logWarning(currentConfiguration, error);\r\n            return throwError(() => new Error(error));\r\n        }\r\n        this.loggerService.logDebug(currentConfiguration, 'Getting signinkeys from ', jwksUri);\r\n        return this.dataService.get(jwksUri, currentConfiguration).pipe(retry(2), catchError((e) => this.handleErrorGetSigningKeys(e, currentConfiguration)));\r\n    }\r\n    handleErrorGetSigningKeys(errorResponse, currentConfiguration) {\r\n        let errMsg = '';\r\n        if (errorResponse instanceof HttpResponse) {\r\n            const body = errorResponse.body || {};\r\n            const err = JSON.stringify(body);\r\n            const { status, statusText } = errorResponse;\r\n            errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\r\n        }\r\n        else {\r\n            const { message } = errorResponse;\r\n            errMsg = !!message ? message : `${errorResponse}`;\r\n        }\r\n        this.loggerService.logError(currentConfiguration, errMsg);\r\n        return throwError(() => new Error(errMsg));\r\n    }\r\n}\r\nSigninKeyDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSigninKeyDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SigninKeyDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SigninKeyDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });\n\nconst JWT_KEYS = 'jwtKeys';\r\nclass HistoryJwtKeysCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService, document) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.signInKeyDataService = signInKeyDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.document = document;\r\n    }\r\n    // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\r\n    callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs) {\r\n        if (!this.responseHasIdToken(callbackContext)) {\r\n            const existingIdToken = this.storagePersistenceService.getIdToken(config);\r\n            callbackContext.authResult = Object.assign(Object.assign({}, callbackContext.authResult), { id_token: existingIdToken });\r\n        }\r\n        this.storagePersistenceService.write('authnResult', callbackContext.authResult, config);\r\n        if (config.allowUnsafeReuseRefreshToken && callbackContext.authResult.refresh_token) {\r\n            this.storagePersistenceService.write('reusable_refresh_token', callbackContext.authResult.refresh_token, config);\r\n        }\r\n        if (this.historyCleanUpTurnedOn(config) && !callbackContext.isRenewProcess) {\r\n            this.resetBrowserHistory();\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(config, 'history clean up inactive');\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\r\n            this.loggerService.logDebug(config, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            this.flowsDataService.setNonce('', config);\r\n            this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(config, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\r\n      AuthCallback created, begin token validation`);\r\n        return this.signInKeyDataService.getSigningKeys(config).pipe(tap((jwtKeys) => this.storeSigningKeys(jwtKeys, config)), catchError((err) => {\r\n            // fallback: try to load jwtKeys from storage\r\n            const storedJwtKeys = this.readSigningKeys(config);\r\n            if (!!storedJwtKeys) {\r\n                this.loggerService.logWarning(config, `Failed to retrieve signing keys, fallback to stored keys`);\r\n                return of(storedJwtKeys);\r\n            }\r\n            return throwError(() => new Error(err));\r\n        }), switchMap((jwtKeys) => {\r\n            if (jwtKeys) {\r\n                callbackContext.jwtKeys = jwtKeys;\r\n                return of(callbackContext);\r\n            }\r\n            const errorMessage = `Failed to retrieve signing key`;\r\n            this.loggerService.logWarning(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve signing key with error: ${err}`;\r\n            this.loggerService.logWarning(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    responseHasIdToken(callbackContext) {\r\n        var _a;\r\n        return !!((_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token);\r\n    }\r\n    handleResultErrorFromCallback(result, isRenewProcess) {\r\n        let validationResult = ValidationResult.SecureTokenServerError;\r\n        if (result.error === 'login_required') {\r\n            validationResult = ValidationResult.LoginRequired;\r\n        }\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    historyCleanUpTurnedOn(config) {\r\n        const { historyCleanupOff } = config;\r\n        return !historyCleanupOff;\r\n    }\r\n    resetBrowserHistory() {\r\n        this.document.defaultView.history.replaceState({}, this.document.title, this.document.defaultView.location.origin + this.document.defaultView.location.pathname);\r\n    }\r\n    storeSigningKeys(jwtKeys, config) {\r\n        this.storagePersistenceService.write(JWT_KEYS, jwtKeys, config);\r\n    }\r\n    readSigningKeys(config) {\r\n        return this.storagePersistenceService.read(JWT_KEYS, config);\r\n    }\r\n}\r\nHistoryJwtKeysCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHistoryJwtKeysCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass UserCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService, userService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 5 userData\r\n    callbackUser(callbackContext, configuration, allConfigs) {\r\n        const { isRenewProcess, validationResult, authResult, refreshToken } = callbackContext;\r\n        const { autoUserInfo, renewUserInfoAfterTokenRenew } = configuration;\r\n        if (!autoUserInfo) {\r\n            if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\r\n                // userData is set to the id_token decoded, auto get user data set to false\r\n                if (validationResult.decodedIdToken) {\r\n                    this.userService.setUserDataToStore(validationResult.decodedIdToken, configuration, allConfigs);\r\n                }\r\n            }\r\n            if (!isRenewProcess && !refreshToken) {\r\n                this.flowsDataService.setSessionState(authResult.session_state, configuration);\r\n            }\r\n            this.publishAuthState(validationResult, isRenewProcess);\r\n            return of(callbackContext);\r\n        }\r\n        return this.userService\r\n            .getAndPersistUserDataInStore(configuration, allConfigs, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)\r\n            .pipe(switchMap((userData) => {\r\n            if (!!userData) {\r\n                if (!refreshToken) {\r\n                    this.flowsDataService.setSessionState(authResult.session_state, configuration);\r\n                }\r\n                this.publishAuthState(validationResult, isRenewProcess);\r\n                return of(callbackContext);\r\n            }\r\n            else {\r\n                this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\r\n                this.publishUnauthenticatedState(validationResult, isRenewProcess);\r\n                const errorMessage = `Called for userData but they were ${userData}`;\r\n                this.loggerService.logWarning(configuration, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve user info with error:  ${err}`;\r\n            this.loggerService.logWarning(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    publishAuthState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: true,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nUserCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UserCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });\n\nclass StateValidationResult {\r\n    constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\r\n        at_hash: '',\r\n    }, state = ValidationResult.NotSet) {\r\n        this.accessToken = accessToken;\r\n        this.idToken = idToken;\r\n        this.authResponseIsValid = authResponseIsValid;\r\n        this.decodedIdToken = decodedIdToken;\r\n        this.state = state;\r\n    }\r\n}\n\nclass EqualityService {\r\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\r\n        if (this.isNullOrUndefined(value1)) {\r\n            return false;\r\n        }\r\n        if (this.isNullOrUndefined(value2)) {\r\n            return false;\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        return this.arraysHaveEqualContent(value1, value2);\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysStrictEqual(value1, value2);\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n        return value1 === value2;\r\n    }\r\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n    bothValuesAreObjects(value1, value2) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n    bothValuesAreStrings(value1, value2) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n    bothValuesAreArrays(value1, value2) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n    valueIsString(value) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n    valueIsObject(value) {\r\n        return typeof value === 'object';\r\n    }\r\n    arraysStrictEqual(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = arr1.length; i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    arraysHaveEqualContent(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        return arr1.some((v) => arr2.includes(v));\r\n    }\r\n    isNullOrUndefined(val) {\r\n        return val === null || val === undefined;\r\n    }\r\n}\r\nEqualityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: EqualityService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nEqualityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: EqualityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: EqualityService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StateValidationService {\r\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, equalityService, flowHelper) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.equalityService = equalityService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    getValidatedStateResult(callbackContext, configuration) {\r\n        if (!callbackContext || callbackContext.authResult.error) {\r\n            return of(new StateValidationResult('', '', false, {}));\r\n        }\r\n        return this.validateState(callbackContext, configuration);\r\n    }\r\n    validateState(callbackContext, configuration) {\r\n        const toReturn = new StateValidationResult();\r\n        const authStateControl = this.storagePersistenceService.read('authStateControl', configuration);\r\n        if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configuration)) {\r\n            this.loggerService.logWarning(configuration, 'authCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation(configuration);\r\n            return of(toReturn);\r\n        }\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configuration);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configuration);\r\n        if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\r\n            toReturn.accessToken = callbackContext.authResult.access_token;\r\n        }\r\n        const disableIdTokenValidation = configuration.disableIdTokenValidation;\r\n        if (disableIdTokenValidation) {\r\n            toReturn.state = ValidationResult.Ok;\r\n            // TODO TESTING\r\n            toReturn.authResponseIsValid = true;\r\n            return of(toReturn);\r\n        }\r\n        const isInRefreshTokenFlow = callbackContext.isRenewProcess && !!callbackContext.refreshToken;\r\n        const hasIdToken = !!callbackContext.authResult.id_token;\r\n        if (isInRefreshTokenFlow && !hasIdToken) {\r\n            toReturn.state = ValidationResult.Ok;\r\n            // TODO TESTING\r\n            toReturn.authResponseIsValid = true;\r\n            return of(toReturn);\r\n        }\r\n        if (callbackContext.authResult.id_token) {\r\n            const { clientId, issValidationOff, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, ignoreNonceAfterRefresh, renewTimeBeforeTokenExpiresInSeconds, } = configuration;\r\n            toReturn.idToken = callbackContext.authResult.id_token;\r\n            toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configuration);\r\n            return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configuration).pipe(mergeMap((isSignatureIdTokenValid) => {\r\n                if (!isSignatureIdTokenValid) {\r\n                    this.loggerService.logDebug(configuration, 'authCallback Signature validation failed id_token');\r\n                    toReturn.state = ValidationResult.SignatureFailed;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                const authNonce = this.storagePersistenceService.read('authNonce', configuration);\r\n                if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\r\n                    toReturn.state = ValidationResult.IncorrectNonce;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configuration)) {\r\n                    this.loggerService.logDebug(configuration, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                    toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!isInRefreshTokenFlow &&\r\n                    !this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                    toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n                if (authWellKnownEndPoints) {\r\n                    if (issValidationOff) {\r\n                        this.loggerService.logDebug(configuration, 'iss validation is turned off, this is not recommended!');\r\n                    }\r\n                    else if (!issValidationOff &&\r\n                        !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configuration)) {\r\n                        this.loggerService.logWarning(configuration, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                        toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                        this.handleUnsuccessfulValidation(configuration);\r\n                        return of(toReturn);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\r\n                    toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect aud');\r\n                    toReturn.state = ValidationResult.IncorrectAud;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback missing azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback pre, post id_token claims do not match in refresh');\r\n                    toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!isInRefreshTokenFlow &&\r\n                    !this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configuration, renewTimeBeforeTokenExpiresInSeconds)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback id token expired');\r\n                    toReturn.state = ValidationResult.TokenExpired;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\r\n            }));\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configuration, 'No id_token found, skipping id_token validation');\r\n        }\r\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\r\n    }\r\n    validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext) {\r\n        // flow id_token\r\n        if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation(configuration);\r\n            this.handleUnsuccessfulValidation(configuration);\r\n            return of(toReturn);\r\n        }\r\n        // only do check if id_token returned, no always the case when using refresh tokens\r\n        if (callbackContext.authResult.id_token) {\r\n            const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configuration);\r\n            if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\r\n                this.loggerService.logDebug(configuration, 'Code Flow active, and no at_hash in the id_token, skipping check!');\r\n            }\r\n            else {\r\n                return this.tokenValidationService\r\n                    .validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\r\n                configuration)\r\n                    .pipe(map((valid) => {\r\n                    if (!valid || !toReturn.accessToken) {\r\n                        this.loggerService.logWarning(configuration, 'authCallback incorrect at_hash');\r\n                        toReturn.state = ValidationResult.IncorrectAtHash;\r\n                        this.handleUnsuccessfulValidation(configuration);\r\n                        return toReturn;\r\n                    }\r\n                    else {\r\n                        toReturn.authResponseIsValid = true;\r\n                        toReturn.state = ValidationResult.Ok;\r\n                        this.handleSuccessfulValidation(configuration);\r\n                        return toReturn;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation(configuration);\r\n        return of(toReturn);\r\n    }\r\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configuration) {\r\n        const { useRefreshToken, disableRefreshIdTokenAuthTimeValidation } = configuration;\r\n        if (!useRefreshToken) {\r\n            return true;\r\n        }\r\n        if (!callbackContext.existingIdToken) {\r\n            return true;\r\n        }\r\n        const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configuration);\r\n        // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\r\n        // except that it might not contain an id_token.\r\n        // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\r\n        // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.iss !== newIdToken.iss) {\r\n            this.loggerService.logDebug(configuration, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\r\n            return false;\r\n        }\r\n        // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\r\n        //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\r\n        // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\r\n        if (decodedIdToken.azp !== newIdToken.azp) {\r\n            this.loggerService.logDebug(configuration, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\r\n            return false;\r\n        }\r\n        // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.sub !== newIdToken.sub) {\r\n            this.loggerService.logDebug(configuration, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\r\n            return false;\r\n        }\r\n        // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\r\n            this.loggerService.logDebug(configuration, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\r\n            return false;\r\n        }\r\n        if (disableRefreshIdTokenAuthTimeValidation) {\r\n            return true;\r\n        }\r\n        // its iat Claim MUST represent the time that the new ID Token is issued,\r\n        // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\r\n        // - not the time that the new ID token is issued,\r\n        if (decodedIdToken.auth_time !== newIdToken.auth_time) {\r\n            this.loggerService.logDebug(configuration, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    handleSuccessfulValidation(configuration) {\r\n        const { autoCleanStateAfterAuthentication } = configuration;\r\n        this.storagePersistenceService.write('authNonce', null, configuration);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configuration);\r\n        }\r\n        this.loggerService.logDebug(configuration, 'authCallback token(s) validated, continue');\r\n    }\r\n    handleUnsuccessfulValidation(configuration) {\r\n        const { autoCleanStateAfterAuthentication } = configuration;\r\n        this.storagePersistenceService.write('authNonce', null, configuration);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configuration);\r\n        }\r\n        this.loggerService.logDebug(configuration, 'authCallback token(s) invalid');\r\n    }\r\n}\r\nStateValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: EqualityService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: EqualityService }, { type: FlowHelper }]; } });\n\nclass StateValidationCallbackHandlerService {\r\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, document) {\r\n        this.loggerService = loggerService;\r\n        this.stateValidationService = stateValidationService;\r\n        this.authStateService = authStateService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.document = document;\r\n    }\r\n    // STEP 4 All flows\r\n    callbackStateValidation(callbackContext, configuration, allConfigs) {\r\n        return this.stateValidationService.getValidatedStateResult(callbackContext, configuration).pipe(map((validationResult) => {\r\n            callbackContext.validationResult = validationResult;\r\n            if (validationResult.authResponseIsValid) {\r\n                this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configuration, allConfigs);\r\n                return callbackContext;\r\n            }\r\n            else {\r\n                const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.document.location.hash}`;\r\n                this.loggerService.logWarning(configuration, errorMessage);\r\n                this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\r\n                this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\r\n                throw new Error(errorMessage);\r\n            }\r\n        }));\r\n    }\r\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nStateValidationCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StateValidationCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass RefreshSessionCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    // STEP 1 Refresh session\r\n    refreshSessionWithRefreshTokens(config) {\r\n        const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\r\n        this.loggerService.logDebug(config, 'RefreshSession created. Adding myautostate: ' + stateData);\r\n        const refreshToken = this.authStateService.getRefreshToken(config);\r\n        const idToken = this.authStateService.getIdToken(config);\r\n        if (refreshToken) {\r\n            const callbackContext = {\r\n                code: null,\r\n                refreshToken,\r\n                state: stateData,\r\n                sessionState: null,\r\n                authResult: null,\r\n                isRenewProcess: true,\r\n                jwtKeys: null,\r\n                validationResult: null,\r\n                existingIdToken: idToken,\r\n            };\r\n            this.loggerService.logDebug(config, 'found refresh code, obtaining new credentials with refresh code');\r\n            // Nonce is not used with refresh tokens; but Key cloak may send it anyway\r\n            this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, config);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = 'no refresh token found, please login';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n    }\r\n}\r\nRefreshSessionCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });\n\nclass RefreshTokenCallbackHandlerService {\r\n    constructor(urlService, loggerService, dataService, storagePersistenceService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    // STEP 2 Refresh Token\r\n    refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);\r\n        return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap((response) => {\r\n            this.loggerService.logDebug(config, 'token refresh response: ', response);\r\n            response.state = callbackContext.state;\r\n            callbackContext.authResult = response;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, config)), catchError((error) => {\r\n            const { authority } = config;\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(config, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, config) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = config;\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(config, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => error);\r\n        }));\r\n    }\r\n}\r\nRefreshTokenCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshTokenCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass FlowsService {\r\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\r\n        this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\r\n        this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\r\n        this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\r\n        this.userHandlerService = userHandlerService;\r\n        this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\r\n        this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\r\n        this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\r\n    }\r\n    processCodeFlowCallback(urlToCheck, config, allConfigs) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, config).pipe(concatMap((callbackContext) => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, config)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processSilentRenewCodeFlowCallback(firstContext, config, allConfigs) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, config).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processImplicitFlowCallback(config, allConfigs, hash) {\r\n        return this.implicitFlowCallbackHandlerService.implicitFlowCallback(config, allConfigs, hash).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processRefreshToken(config, allConfigs, customParamsRefresh) {\r\n        return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(config).pipe(concatMap((callbackContext) => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, config, customParamsRefresh)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n}\r\nFlowsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: FlowsService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });\n\nclass IntervalService {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.runTokenValidationRunning = null;\r\n    }\r\n    isTokenValidationRunning() {\r\n        return !!this.runTokenValidationRunning;\r\n    }\r\n    stopPeriodicTokenCheck() {\r\n        if (this.runTokenValidationRunning) {\r\n            this.runTokenValidationRunning.unsubscribe();\r\n            this.runTokenValidationRunning = null;\r\n        }\r\n    }\r\n    startPeriodicTokenCheck(repeatAfterSeconds) {\r\n        const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\r\n        return new Observable((subscriber) => {\r\n            let intervalId;\r\n            this.zone.runOutsideAngular(() => {\r\n                intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\r\n            });\r\n            return () => {\r\n                clearInterval(intervalId);\r\n            };\r\n        });\r\n    }\r\n}\r\nIntervalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IntervalService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIntervalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IntervalService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: IntervalService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass ImplicitFlowCallbackService {\r\n    constructor(flowsService, router, flowsDataService, intervalService) {\r\n        this.flowsService = flowsService;\r\n        this.router = router;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    authenticatedImplicitFlowCallback(config, allConfigs, hash) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = config;\r\n        return this.flowsService.processImplicitFlowCallback(config, allConfigs, hash).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nImplicitFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: i2.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ImplicitFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: i2.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\nclass SilentRenewService {\r\n    constructor(iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\r\n        this.iFrameService = iFrameService;\r\n        this.flowsService = flowsService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.authStateService = authStateService;\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.intervalService = intervalService;\r\n        this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\r\n    }\r\n    get refreshSessionWithIFrameCompleted$() {\r\n        return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\r\n    }\r\n    getOrCreateIframe(config) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, config);\r\n        }\r\n        return existingIframe;\r\n    }\r\n    isSilentRenewConfigured(configuration) {\r\n        const { useRefreshToken, silentRenew } = configuration;\r\n        return !useRefreshToken && silentRenew;\r\n    }\r\n    codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs) {\r\n        const params = new HttpParams({\r\n            fromString: urlParts[1],\r\n        });\r\n        const error = params.get('error');\r\n        if (error) {\r\n            this.authStateService.updateAndPublishAuthState({\r\n                isAuthenticated: false,\r\n                validationResult: ValidationResult.LoginRequired,\r\n                isRenewProcess: true,\r\n            });\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            this.flowsDataService.setNonce('', config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            return throwError(() => new Error(error));\r\n        }\r\n        const code = params.get('code');\r\n        const state = params.get('state');\r\n        const sessionState = params.get('session_state');\r\n        const callbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: true,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, config, allConfigs).pipe(catchError(() => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n    silentRenewEventHandler(e, config, allConfigs) {\r\n        this.loggerService.logDebug(config, 'silentRenewEventHandler');\r\n        if (!e.detail) {\r\n            return;\r\n        }\r\n        let callback$ = of(null);\r\n        const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(config);\r\n        if (isCodeFlow) {\r\n            const urlParts = e.detail.toString().split('?');\r\n            callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs);\r\n        }\r\n        else {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, e.detail);\r\n        }\r\n        callback$.subscribe({\r\n            next: (callbackContext) => {\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\r\n                this.flowsDataService.resetSilentRenewRunning(config);\r\n            },\r\n            error: (err) => {\r\n                this.loggerService.logError(config, 'Error: ' + err);\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(null);\r\n                this.flowsDataService.resetSilentRenewRunning(config);\r\n            },\r\n        });\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n    }\r\n}\r\nSilentRenewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SilentRenewService, deps: [{ token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSilentRenewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SilentRenewService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SilentRenewService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });\n\nclass CodeFlowCallbackService {\r\n    constructor(flowsService, flowsDataService, intervalService, router) {\r\n        this.flowsService = flowsService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n        this.router = router;\r\n    }\r\n    authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = config;\r\n        return this.flowsService.processCodeFlowCallback(urlToCheck, config, allConfigs).pipe(tap((callbackContext) => {\r\n            this.flowsDataService.resetCodeFlowInProgress(config);\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            this.flowsDataService.resetCodeFlowInProgress(config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CodeFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: i2.Router }]; } });\n\nclass CallbackService {\r\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\r\n        this.urlService = urlService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.codeFlowCallbackService = codeFlowCallbackService;\r\n        this.stsCallbackInternal$ = new Subject();\r\n    }\r\n    get stsCallback$() {\r\n        return this.stsCallbackInternal$.asObservable();\r\n    }\r\n    isCallback(currentUrl) {\r\n        return this.urlService.isCallbackFromSts(currentUrl);\r\n    }\r\n    handleCallbackAndFireEvents(currentCallbackUrl, config, allConfigs) {\r\n        let callback$;\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, config, allConfigs);\r\n        }\r\n        else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(config)) {\r\n            if (currentCallbackUrl === null || currentCallbackUrl === void 0 ? void 0 : currentCallbackUrl.includes('#')) {\r\n                let hash = currentCallbackUrl.substring(currentCallbackUrl.indexOf('#') + 1);\r\n                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, hash);\r\n            }\r\n            else {\r\n                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs);\r\n            }\r\n        }\r\n        return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\r\n    }\r\n}\r\nCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\r\nclass AuthWellKnownDataService {\r\n    constructor(http, loggerService) {\r\n        this.http = http;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getWellKnownEndPointsForConfig(config) {\r\n        const { authWellknownEndpointUrl } = config;\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        return this.getWellKnownDocument(authWellknownEndpointUrl, config).pipe(map((wellKnownEndpoints) => ({\r\n            issuer: wellKnownEndpoints.issuer,\r\n            jwksUri: wellKnownEndpoints.jwks_uri,\r\n            authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\r\n            tokenEndpoint: wellKnownEndpoints.token_endpoint,\r\n            userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\r\n            endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\r\n            checkSessionIframe: wellKnownEndpoints.check_session_iframe,\r\n            revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\r\n            introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\r\n            parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,\r\n        })));\r\n    }\r\n    getWellKnownDocument(wellKnownEndpoint, config) {\r\n        let url = wellKnownEndpoint;\r\n        if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\r\n            url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\r\n        }\r\n        return this.http.get(url, config).pipe(retry(2));\r\n    }\r\n}\r\nAuthWellKnownDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownDataService, deps: [{ token: DataService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: LoggerService }]; } });\n\nclass AuthWellKnownService {\r\n    constructor(dataService, publicEventsService, storagePersistenceService) {\r\n        this.dataService = dataService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    storeWellKnownEndpoints(config, mappedWellKnownEndpoints) {\r\n        this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, config);\r\n    }\r\n    queryAndStoreAuthWellKnownEndPoints(config) {\r\n        const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        if (!!alreadySavedWellKnownEndpoints) {\r\n            return of(alreadySavedWellKnownEndpoints);\r\n        }\r\n        return this.dataService.getWellKnownEndPointsForConfig(config).pipe(tap((mappedWellKnownEndpoints) => this.storeWellKnownEndpoints(config, mappedWellKnownEndpoints)), catchError((error) => {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nAuthWellKnownService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownService, deps: [{ token: AuthWellKnownDataService }, { token: PublicEventsService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthWellKnownService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthWellKnownDataService }, { type: PublicEventsService }, { type: StoragePersistenceService }]; } });\n\nclass RefreshSessionIframeService {\r\n    constructor(document, loggerService, urlService, silentRenewService, rendererFactory) {\r\n        this.document = document;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.renderer = rendererFactory.createRenderer(null, null);\r\n    }\r\n    refreshSessionWithIframe(config, allConfigs, customParams) {\r\n        this.loggerService.logDebug(config, 'BEGIN refresh session Authorize Iframe renew');\r\n        return this.urlService.getRefreshSessionSilentRenewUrl(config, customParams).pipe(switchMap((url) => {\r\n            return this.sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs);\r\n        }));\r\n    }\r\n    sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs) {\r\n        const sessionIframe = this.silentRenewService.getOrCreateIframe(config);\r\n        this.initSilentRenewRequest(config, allConfigs);\r\n        this.loggerService.logDebug(config, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\r\n        return new Observable((observer) => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                this.loggerService.logDebug(config, 'removed event listener from IFrame');\r\n                observer.next(true);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.contentWindow.location.replace(url);\r\n        });\r\n    }\r\n    initSilentRenewRequest(config, allConfigs) {\r\n        const instanceId = Math.random();\r\n        const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', (e) => {\r\n            if (e.detail !== instanceId) {\r\n                initDestroyHandler();\r\n                renewDestroyHandler();\r\n            }\r\n        });\r\n        const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', (e) => this.silentRenewService.silentRenewEventHandler(e, config, allConfigs));\r\n        this.document.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\r\n            detail: instanceId,\r\n        }));\r\n    }\r\n}\r\nRefreshSessionIframeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionIframeService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionIframeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionIframeService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionIframeService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0.RendererFactory2 }];\r\n    } });\n\nclass RefreshSessionRefreshTokenService {\r\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\r\n        this.loggerService = loggerService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsService = flowsService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    refreshSessionWithRefreshTokens(config, allConfigs, customParamsRefresh) {\r\n        this.loggerService.logDebug(config, 'BEGIN refresh session Authorize');\r\n        let refreshTokenFailed = false;\r\n        return this.flowsService.processRefreshToken(config, allConfigs, customParamsRefresh).pipe(catchError((error) => {\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            refreshTokenFailed = true;\r\n            return throwError(() => new Error(error));\r\n        }), finalize(() => refreshTokenFailed && this.intervalService.stopPeriodicTokenCheck()));\r\n    }\r\n}\r\nRefreshSessionRefreshTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionRefreshTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });\n\nconst MAX_RETRY_ATTEMPTS = 3;\r\nclass RefreshSessionService {\r\n    constructor(flowHelper, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\r\n        this.flowHelper = flowHelper;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.authStateService = authStateService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.userService = userService;\r\n    }\r\n    userForceRefreshSession(config, allConfigs, extraCustomParams) {\r\n        this.persistCustomParams(extraCustomParams, config);\r\n        return this.forceRefreshSession(config, allConfigs, extraCustomParams);\r\n    }\r\n    forceRefreshSession(config, allConfigs, extraCustomParams) {\r\n        const { customParamsRefreshTokenRequest, configId } = config;\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n            return this.startRefreshSession(config, allConfigs, mergedParams).pipe(map(() => {\r\n                const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n                if (isAuthenticated) {\r\n                    return {\r\n                        idToken: this.authStateService.getIdToken(config),\r\n                        accessToken: this.authStateService.getAccessToken(config),\r\n                        userData: this.userService.getUserDataFromStore(config),\r\n                        isAuthenticated,\r\n                        configId,\r\n                    };\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = config;\r\n        const timeOutTime = silentRenewTimeoutInSeconds * 1000;\r\n        return forkJoin([\r\n            this.startRefreshSession(config, allConfigs, extraCustomParams),\r\n            this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1)),\r\n        ]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\r\n            var _a, _b;\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n            if (isAuthenticated) {\r\n                return {\r\n                    idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\r\n                    accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\r\n                    userData: this.userService.getUserDataFromStore(config),\r\n                    isAuthenticated,\r\n                    configId,\r\n                };\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    persistCustomParams(extraCustomParams, config) {\r\n        const { useRefreshToken } = config;\r\n        if (extraCustomParams) {\r\n            if (useRefreshToken) {\r\n                this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, config);\r\n            }\r\n            else {\r\n                this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, config);\r\n            }\r\n        }\r\n    }\r\n    startRefreshSession(config, allConfigs, extraCustomParams) {\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\r\n        this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\r\n        const shouldBeExecuted = !isSilentRenewRunning;\r\n        if (!shouldBeExecuted) {\r\n            return of(null);\r\n        }\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config).pipe(switchMap(() => {\r\n            this.flowsDataService.setSilentRenewRunning(config);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, extraCustomParams);\r\n            }\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, extraCustomParams);\r\n        }));\r\n    }\r\n    timeoutRetryStrategy(errorAttempts, config) {\r\n        return errorAttempts.pipe(mergeMap((error, index) => {\r\n            const scalingDuration = 1000;\r\n            const currentAttempt = index + 1;\r\n            if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\r\n                return throwError(() => new Error(error));\r\n            }\r\n            this.loggerService.logDebug(config, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            return timer(currentAttempt * scalingDuration);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RefreshSessionService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowHelper }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });\n\nconst DEFAULT_CONFIG = {\r\n    authority: 'https://please_set',\r\n    authWellknownEndpointUrl: '',\r\n    authWellknownEndpoints: null,\r\n    redirectUrl: 'https://please_set',\r\n    clientId: 'please_set',\r\n    responseType: 'code',\r\n    scope: 'openid email profile',\r\n    hdParam: '',\r\n    postLogoutRedirectUri: 'https://please_set',\r\n    startCheckSession: false,\r\n    silentRenew: false,\r\n    silentRenewUrl: 'https://please_set',\r\n    silentRenewTimeoutInSeconds: 20,\r\n    renewTimeBeforeTokenExpiresInSeconds: 0,\r\n    useRefreshToken: false,\r\n    usePushedAuthorisationRequests: false,\r\n    ignoreNonceAfterRefresh: false,\r\n    postLoginRoute: '/',\r\n    forbiddenRoute: '/forbidden',\r\n    unauthorizedRoute: '/unauthorized',\r\n    autoUserInfo: true,\r\n    autoCleanStateAfterAuthentication: true,\r\n    triggerAuthorizationResultEvent: false,\r\n    logLevel: LogLevel.Warn,\r\n    issValidationOff: false,\r\n    historyCleanupOff: false,\r\n    maxIdTokenIatOffsetAllowedInSeconds: 120,\r\n    disableIatOffsetValidation: false,\r\n    customParamsAuthRequest: {},\r\n    customParamsRefreshTokenRequest: {},\r\n    customParamsEndSessionRequest: {},\r\n    customParamsCodeRequest: {},\r\n    disableRefreshIdTokenAuthTimeValidation: false,\r\n    triggerRefreshWhenIdTokenExpired: true,\r\n    tokenRefreshInSeconds: 4,\r\n    refreshTokenRetryInSeconds: 3,\r\n    ngswBypass: false,\r\n};\n\nconst POSITIVE_VALIDATION_RESULT = {\r\n    result: true,\r\n    messages: [],\r\n    level: null,\r\n};\n\nconst ensureAuthority = (passedConfig) => {\r\n    if (!passedConfig.authority) {\r\n        return {\r\n            result: false,\r\n            messages: ['The authority URL MUST be provided in the configuration! '],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureClientId = (passedConfig) => {\r\n    if (!passedConfig.clientId) {\r\n        return {\r\n            result: false,\r\n            messages: ['The clientId is required and missing from your config!'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst createIdentifierToCheck = (passedConfig) => {\r\n    if (!passedConfig) {\r\n        return null;\r\n    }\r\n    const { authority, clientId, scope } = passedConfig;\r\n    return `${authority}${clientId}${scope}`;\r\n};\r\nconst arrayHasDuplicates = (array) => new Set(array).size !== array.length;\r\nconst ensureNoDuplicatedConfigsRule = (passedConfigs) => {\r\n    const allIdentifiers = passedConfigs.map((x) => createIdentifierToCheck(x));\r\n    const someAreNull = allIdentifiers.some((x) => x === null);\r\n    if (someAreNull) {\r\n        return {\r\n            result: false,\r\n            messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\r\n            level: 'error',\r\n        };\r\n    }\r\n    const hasDuplicates = arrayHasDuplicates(allIdentifiers);\r\n    if (hasDuplicates) {\r\n        return {\r\n            result: false,\r\n            messages: ['You added multiple configs with the same authority, clientId and scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureRedirectRule = (passedConfig) => {\r\n    if (!passedConfig.redirectUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['The redirectUrl is required and missing from your config'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = (passedConfig) => {\r\n    const usesSilentRenew = passedConfig.silentRenew;\r\n    const usesRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenewUrl = passedConfig.silentRenewUrl;\r\n    if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst useOfflineScopeWithSilentRenew = (passedConfig) => {\r\n    const hasRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenew = passedConfig.silentRenew;\r\n    const scope = passedConfig.scope || '';\r\n    const hasOfflineScope = scope.split(' ').includes('offline_access');\r\n    if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\r\n        return {\r\n            result: false,\r\n            messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst allRules = [\r\n    ensureAuthority,\r\n    useOfflineScopeWithSilentRenew,\r\n    ensureRedirectRule,\r\n    ensureClientId,\r\n    ensureSilentRenewUrlWhenNoRefreshTokenUsed,\r\n];\r\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    validateConfigs(passedConfigs) {\r\n        return this.validateConfigsInternal(passedConfigs !== null && passedConfigs !== void 0 ? passedConfigs : [], allMultipleConfigRules);\r\n    }\r\n    validateConfig(passedConfig) {\r\n        return this.validateConfigInternal(passedConfig, allRules);\r\n    }\r\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfigs));\r\n        let overallErrorCount = 0;\r\n        passedConfigs.forEach((passedConfig) => {\r\n            const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\r\n            overallErrorCount += errorCount;\r\n        });\r\n        return overallErrorCount === 0;\r\n    }\r\n    validateConfigInternal(passedConfig, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfig));\r\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\r\n        return errorCount === 0;\r\n    }\r\n    processValidationResultsAndGetErrorCount(allValidationResults, config) {\r\n        const allMessages = allValidationResults.filter((x) => x.messages.length > 0);\r\n        const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\r\n        const allWarnings = this.getAllMessagesOfType('warning', allMessages);\r\n        allErrorMessages.forEach((message) => this.loggerService.logError(config, message));\r\n        allWarnings.forEach((message) => this.loggerService.logWarning(config, message));\r\n        return allErrorMessages.length;\r\n    }\r\n    getAllMessagesOfType(type, results) {\r\n        const allMessages = results.filter((x) => x.level === type).map((result) => result.messages);\r\n        return allMessages.reduce((acc, val) => acc.concat(val), []);\r\n    }\r\n}\r\nConfigValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass PlatformProvider {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n    }\r\n    isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n}\r\nPlatformProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PlatformProvider, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPlatformProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PlatformProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PlatformProvider, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [PLATFORM_ID]\r\n                    }] }];\r\n    } });\n\nclass OpenIdConfigLoader {\r\n}\r\nclass StsConfigLoader {\r\n}\r\nclass StsConfigStaticLoader {\r\n    constructor(passedConfigs) {\r\n        this.passedConfigs = passedConfigs;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.passedConfigs)) {\r\n            return of(this.passedConfigs);\r\n        }\r\n        return of([this.passedConfigs]);\r\n    }\r\n}\r\nclass StsConfigHttpLoader {\r\n    constructor(configs$) {\r\n        this.configs$ = configs$;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.configs$)) {\r\n            return forkJoin(this.configs$);\r\n        }\r\n        const singleConfigOrArray = this.configs$;\r\n        return singleConfigOrArray.pipe(map((value) => {\r\n            if (Array.isArray(value)) {\r\n                return value;\r\n            }\r\n            return [value];\r\n        }));\r\n    }\r\n}\n\nclass ConfigurationService {\r\n    constructor(loggerService, publicEventsService, storagePersistenceService, configValidationService, platformProvider, authWellKnownService, loader) {\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.configValidationService = configValidationService;\r\n        this.platformProvider = platformProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.loader = loader;\r\n        this.configsInternal = {};\r\n    }\r\n    hasManyConfigs() {\r\n        return Object.keys(this.configsInternal).length > 1;\r\n    }\r\n    getAllConfigurations() {\r\n        return Object.values(this.configsInternal);\r\n    }\r\n    getOpenIDConfiguration(configId) {\r\n        if (this.configsAlreadySaved()) {\r\n            return of(this.getConfig(configId));\r\n        }\r\n        return this.getOpenIDConfigurations(configId).pipe(map((result) => result.currentConfig));\r\n    }\r\n    getOpenIDConfigurations(configId) {\r\n        return this.loadConfigs().pipe(concatMap((allConfigs) => this.prepareAndSaveConfigs(allConfigs)), map((allPreparedConfigs) => ({\r\n            allConfigs: allPreparedConfigs,\r\n            currentConfig: this.getConfig(configId),\r\n        })));\r\n    }\r\n    hasAtLeastOneConfig() {\r\n        return Object.keys(this.configsInternal).length > 0;\r\n    }\r\n    saveConfig(readyConfig) {\r\n        const { configId } = readyConfig;\r\n        this.configsInternal[configId] = readyConfig;\r\n    }\r\n    loadConfigs() {\r\n        return this.loader.loadConfigs();\r\n    }\r\n    configsAlreadySaved() {\r\n        return this.hasAtLeastOneConfig();\r\n    }\r\n    getConfig(configId) {\r\n        if (!!configId) {\r\n            return this.configsInternal[configId] || null;\r\n        }\r\n        const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\r\n        return value || null;\r\n    }\r\n    prepareAndSaveConfigs(passedConfigs) {\r\n        if (!this.configValidationService.validateConfigs(passedConfigs)) {\r\n            return of(null);\r\n        }\r\n        this.createUniqueIds(passedConfigs);\r\n        const allHandleConfigs$ = passedConfigs.map((x) => this.handleConfig(x));\r\n        return forkJoin(allHandleConfigs$);\r\n    }\r\n    createUniqueIds(passedConfigs) {\r\n        passedConfigs.forEach((config, index) => {\r\n            if (!config.configId) {\r\n                config.configId = `${index}-${config.clientId}`;\r\n            }\r\n        });\r\n    }\r\n    handleConfig(passedConfig) {\r\n        if (!this.configValidationService.validateConfig(passedConfig)) {\r\n            this.loggerService.logError(passedConfig, 'Validation of config rejected with errors. Config is NOT set.');\r\n            return of(null);\r\n        }\r\n        if (!passedConfig.authWellknownEndpointUrl) {\r\n            passedConfig.authWellknownEndpointUrl = passedConfig.authority;\r\n        }\r\n        const usedConfig = this.prepareConfig(passedConfig);\r\n        this.saveConfig(usedConfig);\r\n        const configWithAuthWellKnown = this.enhanceConfigWithWellKnownEndpoint(usedConfig);\r\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, configWithAuthWellKnown);\r\n        return of(usedConfig);\r\n    }\r\n    enhanceConfigWithWellKnownEndpoint(configuration) {\r\n        const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!!alreadyExistingAuthWellKnownEndpoints) {\r\n            configuration.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\r\n            return configuration;\r\n        }\r\n        const passedAuthWellKnownEndpoints = configuration.authWellknownEndpoints;\r\n        if (!!passedAuthWellKnownEndpoints) {\r\n            this.authWellKnownService.storeWellKnownEndpoints(configuration, passedAuthWellKnownEndpoints);\r\n            configuration.authWellknownEndpoints = passedAuthWellKnownEndpoints;\r\n            return configuration;\r\n        }\r\n        return configuration;\r\n    }\r\n    prepareConfig(configuration) {\r\n        const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\r\n        this.setSpecialCases(openIdConfigurationInternal);\r\n        return openIdConfigurationInternal;\r\n    }\r\n    setSpecialCases(currentConfig) {\r\n        if (!this.platformProvider.isBrowser()) {\r\n            currentConfig.startCheckSession = false;\r\n            currentConfig.silentRenew = false;\r\n            currentConfig.useRefreshToken = false;\r\n            currentConfig.usePushedAuthorisationRequests = false;\r\n        }\r\n    }\r\n}\r\nConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigurationService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }, { token: AuthWellKnownService }, { token: StsConfigLoader }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigurationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConfigurationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }, { type: AuthWellKnownService }, { type: StsConfigLoader }]; } });\n\nclass PeriodicallyTokenCheckService {\r\n    constructor(resetAuthDataService, flowHelper, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService, configurationService) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.userService = userService;\r\n        this.authStateService = authStateService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.intervalService = intervalService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationService = configurationService;\r\n    }\r\n    startTokenValidationPeriodically(allConfigs, currentConfig) {\r\n        const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled(allConfigs);\r\n        if (configsWithSilentRenewEnabled.length <= 0) {\r\n            return;\r\n        }\r\n        if (this.intervalService.isTokenValidationRunning()) {\r\n            return;\r\n        }\r\n        const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\r\n        const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\r\n            const objectWithConfigIdsAndRefreshEvent = {};\r\n            configsWithSilentRenewEnabled.forEach((config) => {\r\n                objectWithConfigIdsAndRefreshEvent[config.configId] = this.getRefreshEvent(config, allConfigs);\r\n            });\r\n            return forkJoin(objectWithConfigIdsAndRefreshEvent);\r\n        }));\r\n        this.intervalService.runTokenValidationRunning = periodicallyCheck$\r\n            .pipe(catchError((error) => throwError(() => new Error(error))))\r\n            .subscribe({\r\n            next: (objectWithConfigIds) => {\r\n                for (const [configId, _] of Object.entries(objectWithConfigIds)) {\r\n                    this.configurationService.getOpenIDConfiguration(configId).subscribe((config) => {\r\n                        this.loggerService.logDebug(config, 'silent renew, periodic check finished!');\r\n                        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                            this.flowsDataService.resetSilentRenewRunning(config);\r\n                        }\r\n                    });\r\n                }\r\n            },\r\n            error: (error) => {\r\n                this.loggerService.logError(currentConfig, 'silent renew failed!', error);\r\n            },\r\n        });\r\n    }\r\n    getRefreshEvent(config, allConfigs) {\r\n        const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(config);\r\n        if (!shouldStartRefreshEvent) {\r\n            return of(null);\r\n        }\r\n        const refreshEvent$ = this.createRefreshEventForConfig(config, allConfigs);\r\n        this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\r\n        const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError((error) => {\r\n            this.loggerService.logError(config, 'silent renew failed!', error);\r\n            this.publicEventsService.fireEvent(EventTypes.SilentRenewFailed, error);\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n        return refreshEventWithErrorHandler$;\r\n    }\r\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\r\n        const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\r\n        return result.tokenRefreshInSeconds;\r\n    }\r\n    getConfigsWithSilentRenewEnabled(allConfigs) {\r\n        return allConfigs.filter((x) => x.silentRenew);\r\n    }\r\n    createRefreshEventForConfig(configuration, allConfigs) {\r\n        this.loggerService.logDebug(configuration, 'starting silent renew...');\r\n        return this.configurationService.getOpenIDConfiguration(configuration.configId).pipe(switchMap((config) => {\r\n            if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\r\n                this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n                return of(null);\r\n            }\r\n            this.flowsDataService.setSilentRenewRunning(config);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                // Retrieve Dynamically Set Custom Params for refresh body\r\n                const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', config) || {};\r\n                const { customParamsRefreshTokenRequest } = config;\r\n                const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh);\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, mergedParams);\r\n            }\r\n            // Retrieve Dynamically Set Custom Params\r\n            const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', config);\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, customParams);\r\n        }));\r\n    }\r\n    shouldStartPeriodicallyCheckForConfig(config) {\r\n        const idToken = this.authStateService.getIdToken(config);\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\r\n        const isCodeFlowinProgress = this.flowsDataService.isCodeFlowInProgress(config);\r\n        const userDataFromStore = this.userService.getUserDataFromStore(config);\r\n        this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}, isCodeFlowInProgress: ${isCodeFlowinProgress} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\r\n        const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken && !isCodeFlowinProgress;\r\n        if (!shouldBeExecuted) {\r\n            return false;\r\n        }\r\n        const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(config);\r\n        if (!accessTokenHasExpired) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nPeriodicallyTokenCheckService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPeriodicallyTokenCheckService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PeriodicallyTokenCheckService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PeriodicallyTokenCheckService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: ConfigurationService }]; } });\n\nclass PopUpService {\r\n    constructor(document, loggerService, storagePersistenceService) {\r\n        this.document = document;\r\n        this.loggerService = loggerService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.STORAGE_IDENTIFIER = 'popupauth';\r\n        this.resultInternal$ = new Subject();\r\n    }\r\n    get result$() {\r\n        return this.resultInternal$.asObservable();\r\n    }\r\n    get windowInternal() {\r\n        return this.document.defaultView;\r\n    }\r\n    currentWindowIsPopUp() {\r\n        return !!this.windowInternal.opener && this.windowInternal.opener !== this.windowInternal;\r\n    }\r\n    isCurrentlyInPopup(config) {\r\n        if (this.canAccessSessionStorage()) {\r\n            const mainWindowHasPopupOpen = this.mainWindowHasPopupOpen(config);\r\n            const currentWindowIsPopup = this.currentWindowIsPopUp();\r\n            return mainWindowHasPopupOpen || currentWindowIsPopup;\r\n        }\r\n        return false;\r\n    }\r\n    openPopUp(url, popupOptions, config) {\r\n        const optionsToPass = this.getOptions(popupOptions);\r\n        this.popUp = this.windowInternal.open(url, '_blank', optionsToPass);\r\n        if (!this.popUp) {\r\n            this.loggerService.logError(config, 'Could not open popup');\r\n            return;\r\n        }\r\n        this.storagePersistenceService.write(this.STORAGE_IDENTIFIER, 'true', config);\r\n        const listener = (event) => {\r\n            if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\r\n                this.cleanUp(listener, config);\r\n                return;\r\n            }\r\n            this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });\r\n            this.cleanUp(listener, config);\r\n        };\r\n        this.windowInternal.addEventListener('message', listener, false);\r\n        this.handle = this.windowInternal.setInterval(() => {\r\n            var _a;\r\n            if ((_a = this.popUp) === null || _a === void 0 ? void 0 : _a.closed) {\r\n                this.resultInternal$.next({ userClosed: true });\r\n                this.cleanUp(listener, config);\r\n            }\r\n        }, 200);\r\n    }\r\n    sendMessageToMainWindow(url) {\r\n        if (this.windowInternal.opener) {\r\n            const href = this.windowInternal.location.href;\r\n            this.sendMessage(url, href);\r\n        }\r\n    }\r\n    cleanUp(listener, config) {\r\n        this.windowInternal.removeEventListener('message', listener, false);\r\n        this.windowInternal.clearInterval(this.handle);\r\n        if (this.popUp) {\r\n            this.storagePersistenceService.remove(this.STORAGE_IDENTIFIER, config);\r\n            this.popUp.close();\r\n            this.popUp = null;\r\n        }\r\n    }\r\n    sendMessage(url, href) {\r\n        this.windowInternal.opener.postMessage(url, href);\r\n    }\r\n    getOptions(popupOptions) {\r\n        const popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };\r\n        const options = Object.assign(Object.assign({}, popupDefaultOptions), (popupOptions || {}));\r\n        const left = this.windowInternal.screenLeft + (this.windowInternal.outerWidth - options.width) / 2;\r\n        const top = this.windowInternal.screenTop + (this.windowInternal.outerHeight - options.height) / 2;\r\n        options.left = left;\r\n        options.top = top;\r\n        return Object.entries(options)\r\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\r\n            .join(',');\r\n    }\r\n    mainWindowHasPopupOpen(config) {\r\n        return !!this.storagePersistenceService.read(this.STORAGE_IDENTIFIER, config);\r\n    }\r\n    canAccessSessionStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nPopUpService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: LoggerService }, { type: StoragePersistenceService }];\r\n    } });\n\nconst STORAGE_KEY = 'redirect';\r\nclass AutoLoginService {\r\n    constructor(storageService, router) {\r\n        this.storageService = storageService;\r\n        this.router = router;\r\n    }\r\n    checkSavedRedirectRouteAndNavigate(config) {\r\n        const savedRouteForRedirect = this.getStoredRedirectRoute(config);\r\n        if (savedRouteForRedirect) {\r\n            this.deleteStoredRedirectRoute(config);\r\n            this.router.navigateByUrl(savedRouteForRedirect);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the redirect URL to storage.\r\n     *\r\n     * @param url The redirect URL to save.\r\n     */\r\n    saveRedirectRoute(config, url) {\r\n        this.storageService.write(STORAGE_KEY, url, config);\r\n    }\r\n    /**\r\n     * Gets the stored redirect URL from storage.\r\n     */\r\n    getStoredRedirectRoute(config) {\r\n        return this.storageService.read(STORAGE_KEY, config);\r\n    }\r\n    /**\r\n     * Removes the redirect URL from storage.\r\n     */\r\n    deleteStoredRedirectRoute(config) {\r\n        this.storageService.remove(STORAGE_KEY, config);\r\n    }\r\n}\r\nAutoLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2.Router }]; } });\n\nclass CheckAuthService {\r\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService, publicEventsService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.currentUrlService = currentUrlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.callbackService = callbackService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.periodicallyTokenCheckService = periodicallyTokenCheckService;\r\n        this.popupService = popupService;\r\n        this.autoLoginService = autoLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n    }\r\n    checkAuth(configuration, allConfigs, url) {\r\n        this.publicEventsService.fireEvent(EventTypes.CheckingAuth);\r\n        const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl(url);\r\n        if (!!stateParamFromUrl) {\r\n            configuration = this.getConfigurationWithUrlState([configuration], stateParamFromUrl);\r\n            if (!configuration) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n        }\r\n        return this.checkAuthWithConfig(configuration, allConfigs, url);\r\n    }\r\n    checkAuthMultiple(allConfigs, url) {\r\n        const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl(url);\r\n        if (stateParamFromUrl) {\r\n            const config = this.getConfigurationWithUrlState(allConfigs, stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n            return this.composeMultipleLoginResults(allConfigs, config, url);\r\n        }\r\n        const configs = allConfigs;\r\n        const allChecks$ = configs.map((x) => this.checkAuthWithConfig(x, configs, url));\r\n        return forkJoin(allChecks$);\r\n    }\r\n    checkAuthIncludingServer(configuration, allConfigs) {\r\n        return this.checkAuthWithConfig(configuration, allConfigs).pipe(switchMap((loginResponse) => {\r\n            const { isAuthenticated } = loginResponse;\r\n            if (isAuthenticated) {\r\n                return of(loginResponse);\r\n            }\r\n            return this.refreshSessionService.forceRefreshSession(configuration, allConfigs).pipe(tap((loginResponseAfterRefreshSession) => {\r\n                if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\r\n                    this.startCheckSessionAndValidation(configuration, allConfigs);\r\n                }\r\n            }));\r\n        }));\r\n    }\r\n    checkAuthWithConfig(config, allConfigs, url) {\r\n        if (!config) {\r\n            const errorMessage = 'Please provide at least one configuration before setting up the module';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId: null });\r\n        }\r\n        const currentUrl = url || this.currentUrlService.getCurrentUrl();\r\n        const { configId, authority } = config;\r\n        this.loggerService.logDebug(config, `Working with config '${configId}' using ${authority}`);\r\n        if (this.popupService.currentWindowIsPopUp()) {\r\n            this.popupService.sendMessageToMainWindow(currentUrl);\r\n            return of(null);\r\n        }\r\n        const isCallback = this.callbackService.isCallback(currentUrl);\r\n        this.loggerService.logDebug(config, 'currentUrl to check auth with: ', currentUrl);\r\n        const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, config, allConfigs) : of(null);\r\n        return callback$.pipe(map(() => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n            if (isAuthenticated) {\r\n                this.startCheckSessionAndValidation(config, allConfigs);\r\n                if (!isCallback) {\r\n                    this.authStateService.setAuthenticatedAndFireEvent(allConfigs);\r\n                    this.userService.publishUserDataIfExists(config, allConfigs);\r\n                }\r\n            }\r\n            this.loggerService.logDebug(config, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\r\n            return {\r\n                isAuthenticated,\r\n                userData: this.userService.getUserDataFromStore(config),\r\n                accessToken: this.authStateService.getAccessToken(config),\r\n                idToken: this.authStateService.getIdToken(config),\r\n                configId,\r\n            };\r\n        }), tap(({ isAuthenticated }) => {\r\n            this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinished);\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\r\n            }\r\n        }), catchError(({ message }) => {\r\n            this.loggerService.logError(config, message);\r\n            this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinishedWithError, message);\r\n            return of({ isAuthenticated: false, errorMessage: message, userData: null, idToken: null, accessToken: null, configId });\r\n        }));\r\n    }\r\n    startCheckSessionAndValidation(config, allConfigs) {\r\n        if (this.checkSessionService.isCheckSessionConfigured(config)) {\r\n            this.checkSessionService.start(config);\r\n        }\r\n        this.periodicallyTokenCheckService.startTokenValidationPeriodically(allConfigs, config);\r\n        if (this.silentRenewService.isSilentRenewConfigured(config)) {\r\n            this.silentRenewService.getOrCreateIframe(config);\r\n        }\r\n    }\r\n    getConfigurationWithUrlState(configurations, stateFromUrl) {\r\n        for (const config of configurations) {\r\n            const storedState = this.storagePersistenceService.read('authStateControl', config);\r\n            if (storedState === stateFromUrl) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    composeMultipleLoginResults(configurations, activeConfig, url) {\r\n        const allOtherConfigs = configurations.filter((x) => x.configId !== activeConfig.configId);\r\n        const currentConfigResult = this.checkAuthWithConfig(activeConfig, configurations, url);\r\n        const allOtherConfigResults = allOtherConfigs.map((config) => {\r\n            const { redirectUrl } = config;\r\n            return this.checkAuthWithConfig(config, configurations, redirectUrl);\r\n        });\r\n        return forkJoin([currentConfigResult, ...allOtherConfigResults]);\r\n    }\r\n}\r\nCheckAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: CheckAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });\n\nclass ClosestMatchingRouteService {\r\n    getConfigIdForClosestMatchingRoute(route, configurations) {\r\n        for (const config of configurations) {\r\n            const { secureRoutes } = config;\r\n            for (const configuredRoute of secureRoutes) {\r\n                if (route.startsWith(configuredRoute)) {\r\n                    return {\r\n                        matchingRoute: configuredRoute,\r\n                        matchingConfig: config,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            matchingRoute: null,\r\n            matchingConfig: null,\r\n        };\r\n    }\r\n}\r\nClosestMatchingRouteService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ClosestMatchingRouteService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nClosestMatchingRouteService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ClosestMatchingRouteService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ClosestMatchingRouteService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass ConsoleLoggerService {\r\n    logError(message, ...args) {\r\n        console.error(message, ...args);\r\n    }\r\n    logWarning(message, ...args) {\r\n        console.warn(message, ...args);\r\n    }\r\n    logDebug(message, ...args) {\r\n        console.debug(message, ...args);\r\n    }\r\n}\r\nConsoleLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConsoleLoggerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nConsoleLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConsoleLoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ConsoleLoggerService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass ResponseTypeValidationService {\r\n    constructor(loggerService, flowHelper) {\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    hasConfigValidResponseType(configuration) {\r\n        if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configuration)) {\r\n            return true;\r\n        }\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\r\n            return true;\r\n        }\r\n        this.loggerService.logWarning(configuration, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\r\n        return false;\r\n    }\r\n}\r\nResponseTypeValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResponseTypeValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResponseTypeValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ResponseTypeValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });\n\nclass RedirectService {\r\n    constructor(document) {\r\n        this.document = document;\r\n    }\r\n    redirectTo(url) {\r\n        this.document.location.href = url;\r\n    }\r\n}\r\nRedirectService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RedirectService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRedirectService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RedirectService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: RedirectService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }];\r\n    } });\n\nclass ParService {\r\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    postParRequest(configuration, customParams) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndpoints) {\r\n            return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\r\n        }\r\n        const parEndpoint = authWellKnownEndpoints.parEndpoint;\r\n        if (!parEndpoint) {\r\n            return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\r\n        }\r\n        return this.urlService.createBodyForParCodeFlowRequest(configuration, customParams).pipe(switchMap((data) => {\r\n            return this.dataService.post(parEndpoint, data, configuration, headers).pipe(retry(2), map((response) => {\r\n                this.loggerService.logDebug(configuration, 'par response: ', response);\r\n                return {\r\n                    expiresIn: response.expires_in,\r\n                    requestUri: response.request_uri,\r\n                };\r\n            }), catchError((error) => {\r\n                const errorMessage = `There was an error on ParService postParRequest`;\r\n                this.loggerService.logError(configuration, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass ParLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, popupService, checkAuthService, parService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.parService = parService;\r\n    }\r\n    loginPar(configuration, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            this.loggerService.logError(configuration, 'Invalid response type!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.authWellKnownService\r\n            .queryAndStoreAuthWellKnownEndPoints(configuration)\r\n            .pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)))\r\n            .subscribe((response) => {\r\n            this.loggerService.logDebug(configuration, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\r\n            this.loggerService.logDebug(configuration, 'par request url: ', url);\r\n            if (!url) {\r\n                this.loggerService.logError(configuration, `Could not create URL with param ${response.requestUri}: '${url}'`);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n    loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions) {\r\n        const { configId } = configuration;\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        const { customParams } = authOptions || {};\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)), switchMap((response) => {\r\n            this.loggerService.logDebug(configuration, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\r\n            this.loggerService.logDebug(configuration, 'par request url: ', url);\r\n            if (!url) {\r\n                const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\r\n                this.loggerService.logError(configuration, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n            this.popupService.openPopUp(url, popupOptions, configuration);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ParLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });\n\nclass PopUpLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, authWellKnownService, popupService, checkAuthService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n    }\r\n    loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions) {\r\n        const { configId } = configuration;\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.urlService.getAuthorizeUrl(configuration, authOptions)), tap((authUrl) => this.popupService.openPopUp(authUrl, popupOptions, configuration)), switchMap(() => {\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nPopUpLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: PopUpLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });\n\nclass StandardLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    loginStandard(configuration, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            this.loggerService.logError(configuration, 'Invalid response type!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        this.flowsDataService.setCodeFlowInProgress(configuration);\r\n        this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).subscribe(() => {\r\n            const { urlHandler } = authOptions || {};\r\n            this.flowsDataService.resetSilentRenewRunning(configuration);\r\n            this.urlService.getAuthorizeUrl(configuration, authOptions).subscribe((url) => {\r\n                if (!url) {\r\n                    this.loggerService.logError(configuration, 'Could not create URL', url);\r\n                    return;\r\n                }\r\n                if (urlHandler) {\r\n                    urlHandler(url);\r\n                }\r\n                else {\r\n                    this.redirectService.redirectTo(url);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nStandardLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: AuthWellKnownService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStandardLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StandardLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: StandardLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: AuthWellKnownService }, { type: FlowsDataService }]; } });\n\nclass LoginService {\r\n    constructor(parLoginService, popUpLoginService, standardLoginService, storagePersistenceService, popupService) {\r\n        this.parLoginService = parLoginService;\r\n        this.popUpLoginService = popUpLoginService;\r\n        this.standardLoginService = standardLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.popupService = popupService;\r\n    }\r\n    login(configuration, authOptions) {\r\n        const { usePushedAuthorisationRequests } = configuration;\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\r\n        }\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginPar(configuration, authOptions);\r\n        }\r\n        else {\r\n            return this.standardLoginService.loginStandard(configuration, authOptions);\r\n        }\r\n    }\r\n    loginWithPopUp(configuration, allConfigs, authOptions, popupOptions) {\r\n        const isAlreadyInPopUp = this.popupService.isCurrentlyInPopup(configuration);\r\n        if (isAlreadyInPopUp) {\r\n            return of({ errorMessage: 'There is already a popup open.' });\r\n        }\r\n        const { usePushedAuthorisationRequests } = configuration;\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\r\n        }\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions);\r\n        }\r\n        return this.popUpLoginService.loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions);\r\n    }\r\n}\r\nLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoginService, deps: [{ token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }, { token: PopUpService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }, { type: PopUpService }]; } });\n\nfunction removeNullAndUndefinedValues(obj) {\r\n    const copy = Object.assign({}, obj);\r\n    for (const key in obj) {\r\n        if (obj[key] === undefined || obj[key] === null) {\r\n            delete copy[key];\r\n        }\r\n    }\r\n    return copy;\r\n}\n\nclass LogoffRevocationService {\r\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService) {\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.checkSessionService = checkSessionService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.redirectService = redirectService;\r\n    }\r\n    // Logs out on the server and the local client.\r\n    // If the server state has changed, check session, then only a local logout.\r\n    logoff(config, allConfigs, logoutAuthOptions) {\r\n        this.loggerService.logDebug(config, 'logoff, remove auth', logoutAuthOptions);\r\n        const { urlHandler, customParams } = logoutAuthOptions || {};\r\n        const endSessionUrl = this.urlService.getEndSessionUrl(config, customParams);\r\n        if (!endSessionUrl) {\r\n            this.loggerService.logDebug(config, 'No endsessionUrl present. Logoff was only locally. Returning.');\r\n            return of(null);\r\n        }\r\n        if (this.checkSessionService.serverStateChanged(config)) {\r\n            this.loggerService.logDebug(config, 'Server State changed. Logoff was only locally. Returning.');\r\n            return of(null);\r\n        }\r\n        if (urlHandler) {\r\n            this.loggerService.logDebug(config, `Custom UrlHandler found. Using this to handle logoff with url '${endSessionUrl}'`);\r\n            urlHandler(endSessionUrl);\r\n            return of(null);\r\n        }\r\n        return this.logoffInternal(logoutAuthOptions, endSessionUrl, config, allConfigs);\r\n    }\r\n    logoffLocal(config, allConfigs) {\r\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        this.checkSessionService.stop();\r\n    }\r\n    logoffLocalMultiple(allConfigs) {\r\n        allConfigs.forEach((configuration) => this.logoffLocal(configuration, allConfigs));\r\n    }\r\n    // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n    // only the access token is revoked. Then the logout run.\r\n    logoffAndRevokeTokens(config, allConfigs, logoutAuthOptions) {\r\n        const { revocationEndpoint } = this.storagePersistenceService.read('authWellKnownEndPoints', config) || {};\r\n        if (!revocationEndpoint) {\r\n            this.loggerService.logDebug(config, 'revocation endpoint not supported');\r\n            return this.logoff(config, allConfigs, logoutAuthOptions);\r\n        }\r\n        if (this.storagePersistenceService.getRefreshToken(config)) {\r\n            return this.revokeRefreshToken(config).pipe(switchMap((_) => this.revokeAccessToken(config)), catchError((error) => {\r\n                const errorMessage = `revoke token failed`;\r\n                this.loggerService.logError(config, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), concatMap(() => this.logoff(config, allConfigs, logoutAuthOptions)));\r\n        }\r\n        else {\r\n            return this.revokeAccessToken(config).pipe(catchError((error) => {\r\n                const errorMessage = `revoke accessToken failed`;\r\n                this.loggerService.logError(config, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), concatMap(() => this.logoff(config, allConfigs, logoutAuthOptions)));\r\n        }\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an access token on the STS. If no token is provided, then the token from\r\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\r\n    // manage your own tokens. The is a public API.\r\n    revokeAccessToken(configuration, accessToken) {\r\n        const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configuration);\r\n        const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configuration);\r\n        return this.sendRevokeRequest(configuration, body);\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\r\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n    // This makes it possible to manage your own tokens.\r\n    revokeRefreshToken(configuration, refreshToken) {\r\n        const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configuration);\r\n        const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configuration);\r\n        return this.sendRevokeRequest(configuration, body);\r\n    }\r\n    logoffInternal(logoutAuthOptions, endSessionUrl, config, allConfigs) {\r\n        const { logoffMethod, customParams } = logoutAuthOptions || {};\r\n        if (!logoffMethod || logoffMethod === 'GET') {\r\n            this.redirectService.redirectTo(endSessionUrl);\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            return of(null);\r\n        }\r\n        const { state, logout_hint, ui_locales } = customParams || {};\r\n        const { clientId } = config;\r\n        const idToken = this.storagePersistenceService.getIdToken(config);\r\n        const postLogoutRedirectUrl = this.urlService.getPostLogoutRedirectUrl(config);\r\n        const headers = this.getHeaders();\r\n        const { url } = this.urlService.getEndSessionEndpoint(config);\r\n        const body = {\r\n            id_token_hint: idToken,\r\n            client_id: clientId,\r\n            post_logout_redirect_uri: postLogoutRedirectUrl,\r\n            state,\r\n            logout_hint,\r\n            ui_locales,\r\n        };\r\n        const bodyWithoutNullOrUndefined = removeNullAndUndefinedValues(body);\r\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        return this.dataService.post(url, bodyWithoutNullOrUndefined, config, headers);\r\n    }\r\n    sendRevokeRequest(configuration, body) {\r\n        const url = this.urlService.getRevocationEndpointUrl(configuration);\r\n        const headers = this.getHeaders();\r\n        return this.dataService.post(url, body, configuration, headers).pipe(retry(2), switchMap((response) => {\r\n            this.loggerService.logDebug(configuration, 'revocation endpoint post response: ', response);\r\n            return of(response);\r\n        }), catchError((error) => {\r\n            const errorMessage = `Revocation request failed`;\r\n            this.loggerService.logError(configuration, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    getHeaders() {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return headers;\r\n    }\r\n}\r\nLogoffRevocationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLogoffRevocationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LogoffRevocationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: LogoffRevocationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }]; } });\n\nclass OidcSecurityService {\r\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationService, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService, authWellKnownService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.userService = userService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.configurationService = configurationService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.callbackService = callbackService;\r\n        this.logoffRevocationService = logoffRevocationService;\r\n        this.loginService = loginService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.urlService = urlService;\r\n        this.authWellKnownService = authWellKnownService;\r\n    }\r\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\r\n    get userData$() {\r\n        return this.userService.userData$;\r\n    }\r\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\r\n    get isAuthenticated$() {\r\n        return this.authStateService.authenticated$;\r\n    }\r\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionService.checkSessionChanged$;\r\n    }\r\n    /**\r\n     * Emits on a Security Token Service callback. The observable will never contain a value.\r\n     */\r\n    get stsCallback$() {\r\n        return this.callbackService.stsCallback$;\r\n    }\r\n    preloadAuthWellKnownDocument(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(concatMap((config) => this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config)));\r\n    }\r\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\r\n    getConfigurations() {\r\n        return this.configurationService.getAllConfigurations();\r\n    }\r\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\r\n    getConfiguration(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId);\r\n    }\r\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\r\n    getUserData(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.userService.getUserDataFromStore(config)));\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\r\n    checkAuth(url, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.checkAuthService.checkAuth(currentConfig, allConfigs, url)));\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\r\n    checkAuthMultiple(url) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations()\r\n            .pipe(concatMap(({ allConfigs }) => this.checkAuthService.checkAuthMultiple(allConfigs, url)));\r\n    }\r\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\r\n    isAuthenticated(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.isAuthenticated(config)));\r\n    }\r\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\r\n    checkAuthIncludingServer(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.checkAuthService.checkAuthIncludingServer(currentConfig, allConfigs)));\r\n    }\r\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\r\n    getAccessToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getAccessToken(config)));\r\n    }\r\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\r\n    getIdToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getIdToken(config)));\r\n    }\r\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\r\n    getRefreshToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getRefreshToken(config)));\r\n    }\r\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\r\n    getAuthenticationResult(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.authStateService.getAuthenticationResult(config)));\r\n    }\r\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\r\n    getPayloadFromIdToken(encode = false, configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => {\r\n            const token = this.authStateService.getIdToken(config);\r\n            return this.tokenHelperService.getPayloadFromToken(token, encode, config);\r\n        }));\r\n    }\r\n    /**\r\n     * Returns the payload from the access token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the access token.\r\n     */\r\n    getPayloadFromAccessToken(encode = false, configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => {\r\n            const token = this.authStateService.getAccessToken(config);\r\n            return this.tokenHelperService.getPayloadFromToken(token, encode, config);\r\n        }));\r\n    }\r\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\r\n    setState(state, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.flowsDataService.setAuthStateControl(state, config)));\r\n    }\r\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\r\n    getState(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.flowsDataService.getAuthStateControl(config)));\r\n    }\r\n    /**\r\n     * Redirects the user to the Security Token Service to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\r\n    authorize(configId, authOptions) {\r\n        this.configurationService.getOpenIDConfiguration(configId).subscribe((config) => this.loginService.login(config, authOptions));\r\n    }\r\n    /**\r\n     * Opens the Security Token Service in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.loginService.loginWithPopUp(currentConfig, allConfigs, authOptions, popupOptions)));\r\n    }\r\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    forceRefreshSession(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.refreshSessionService.userForceRefreshSession(currentConfig, allConfigs, customParams)));\r\n    }\r\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    logoffAndRevokeTokens(configId, logoutAuthOptions) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoffAndRevokeTokens(currentConfig, allConfigs, logoutAuthOptions)));\r\n    }\r\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\r\n    logoff(configId, logoutAuthOptions) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(concatMap(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoff(currentConfig, allConfigs, logoutAuthOptions)));\r\n    }\r\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\r\n    logoffLocal(configId) {\r\n        this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .subscribe(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoffLocal(currentConfig, allConfigs));\r\n    }\r\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\r\n    logoffLocalMultiple() {\r\n        this.configurationService\r\n            .getOpenIDConfigurations()\r\n            .subscribe(({ allConfigs }) => this.logoffRevocationService.logoffLocalMultiple(allConfigs));\r\n    }\r\n    /**\r\n     * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeAccessToken(accessToken, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(concatMap((config) => this.logoffRevocationService.revokeAccessToken(config, accessToken)));\r\n    }\r\n    /**\r\n     * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeRefreshToken(refreshToken, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(concatMap((config) => this.logoffRevocationService.revokeRefreshToken(config, refreshToken)));\r\n    }\r\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\r\n    getEndSessionUrl(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.urlService.getEndSessionUrl(config, customParams)));\r\n    }\r\n    /**\r\n     * Creates the authorize URL based on your flow\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the authorize URL or null\r\n     */\r\n    getAuthorizeUrl(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(concatMap((config) => this.urlService.getAuthorizeUrl(config, customParams ? { customParams } : undefined)));\r\n    }\r\n}\r\nOidcSecurityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationService }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }, { token: UrlService }, { token: AuthWellKnownService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcSecurityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OidcSecurityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OidcSecurityService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationService }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }, { type: UrlService }, { type: AuthWellKnownService }]; } });\n\nclass DefaultSessionStorageService {\r\n    read(key) {\r\n        return sessionStorage.getItem(key);\r\n    }\r\n    write(key, value) {\r\n        sessionStorage.setItem(key, value);\r\n    }\r\n    remove(key) {\r\n        sessionStorage.removeItem(key);\r\n    }\r\n    clear() {\r\n        sessionStorage.clear();\r\n    }\r\n}\r\nDefaultSessionStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultSessionStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultSessionStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultSessionStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultSessionStorageService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction createStaticLoader(passedConfig) {\r\n    return new StsConfigStaticLoader(passedConfig.config);\r\n}\r\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\r\nclass AuthModule {\r\n    static forRoot(passedConfig) {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                // Make the PASSED_CONFIG available through injection\r\n                { provide: PASSED_CONFIG, useValue: passedConfig },\r\n                // Create the loader: Either the one getting passed or a static one\r\n                (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },\r\n                ConfigurationService,\r\n                PublicEventsService,\r\n                FlowHelper,\r\n                OidcSecurityService,\r\n                TokenValidationService,\r\n                PlatformProvider,\r\n                CheckSessionService,\r\n                FlowsDataService,\r\n                FlowsService,\r\n                SilentRenewService,\r\n                LogoffRevocationService,\r\n                UserService,\r\n                RandomService,\r\n                HttpBaseService,\r\n                UrlService,\r\n                AuthStateService,\r\n                SigninKeyDataService,\r\n                StoragePersistenceService,\r\n                TokenHelperService,\r\n                IFrameService,\r\n                EqualityService,\r\n                LoginService,\r\n                ParService,\r\n                AuthWellKnownDataService,\r\n                AuthWellKnownService,\r\n                DataService,\r\n                StateValidationService,\r\n                ConfigValidationService,\r\n                CheckAuthService,\r\n                ResetAuthDataService,\r\n                ImplicitFlowCallbackService,\r\n                HistoryJwtKeysCallbackHandlerService,\r\n                ResponseTypeValidationService,\r\n                UserCallbackHandlerService,\r\n                StateValidationCallbackHandlerService,\r\n                RefreshSessionCallbackHandlerService,\r\n                RefreshTokenCallbackHandlerService,\r\n                CodeFlowCallbackHandlerService,\r\n                ImplicitFlowCallbackHandlerService,\r\n                ParLoginService,\r\n                PopUpLoginService,\r\n                StandardLoginService,\r\n                AutoLoginService,\r\n                JwkExtractor,\r\n                JwkWindowCryptoService,\r\n                JwtWindowCryptoService,\r\n                CurrentUrlService,\r\n                ClosestMatchingRouteService,\r\n                DefaultSessionStorageService,\r\n                BrowserStorageService,\r\n                CryptoService,\r\n                LoggerService,\r\n                { provide: AbstractSecurityStorage, useClass: DefaultSessionStorageService },\r\n                { provide: AbstractLoggerService, useClass: ConsoleLoggerService },\r\n            ],\r\n        };\r\n    }\r\n}\r\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule, HttpClientModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nclass AutoLoginAllRoutesGuard {\r\n    constructor(autoLoginService, checkAuthService, loginService, configurationService, router) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.loginService = loginService;\r\n        this.configurationService = configurationService;\r\n        this.router = router;\r\n    }\r\n    canLoad() {\r\n        var _a, _b;\r\n        return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        return this.configurationService.getOpenIDConfiguration().pipe(switchMap((config) => {\r\n            const allconfigs = this.configurationService.getAllConfigurations();\r\n            return this.checkAuthService.checkAuth(config, allconfigs).pipe(take(1), map(({ isAuthenticated }) => {\r\n                if (isAuthenticated) {\r\n                    this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\r\n                }\r\n                if (!isAuthenticated) {\r\n                    this.autoLoginService.saveRedirectRoute(config, url);\r\n                    this.loginService.login(config);\r\n                }\r\n                return isAuthenticated;\r\n            }));\r\n        }));\r\n    }\r\n}\r\nAutoLoginAllRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginAllRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationService }, { type: i2.Router }]; } });\n\nclass AutoLoginPartialRoutesGuard {\r\n    constructor(autoLoginService, authStateService, loginService, configurationService, router) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.authStateService = authStateService;\r\n        this.loginService = loginService;\r\n        this.configurationService = configurationService;\r\n        this.router = router;\r\n    }\r\n    canLoad() {\r\n        var _a, _b;\r\n        return this.checkAuth((_b = (_a = this.router.getCurrentNavigation()) === null || _a === void 0 ? void 0 : _a.extractedUrl.toString().substring(1)) !== null && _b !== void 0 ? _b : '');\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        return this.configurationService.getOpenIDConfiguration().pipe(map((configuration) => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configuration);\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configuration);\r\n            }\r\n            if (!isAuthenticated) {\r\n                this.autoLoginService.saveRedirectRoute(configuration, url);\r\n                this.loginService.login(configuration);\r\n            }\r\n            return isAuthenticated;\r\n        }));\r\n    }\r\n}\r\nAutoLoginPartialRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginPartialRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationService }, { type: i2.Router }]; } });\n\nclass AuthInterceptor {\r\n    constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {\r\n        this.authStateService = authStateService;\r\n        this.configurationService = configurationService;\r\n        this.loggerService = loggerService;\r\n        this.closestMatchingRouteService = closestMatchingRouteService;\r\n    }\r\n    intercept(req, next) {\r\n        return interceptRequest(req, next.handle, {\r\n            configurationService: this.configurationService,\r\n            authStateService: this.authStateService,\r\n            closestMatchingRouteService: this.closestMatchingRouteService,\r\n            loggerService: this.loggerService,\r\n        });\r\n    }\r\n}\r\nAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationService }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: AuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationService }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });\r\nfunction authInterceptor() {\r\n    return (req, next) => {\r\n        return interceptRequest(req, next, {\r\n            configurationService: inject(ConfigurationService),\r\n            authStateService: inject(AuthStateService),\r\n            closestMatchingRouteService: inject(ClosestMatchingRouteService),\r\n            loggerService: inject(LoggerService),\r\n        });\r\n    };\r\n}\r\nfunction interceptRequest(req, next, deps) {\r\n    if (!deps.configurationService.hasAtLeastOneConfig()) {\r\n        return next(req);\r\n    }\r\n    const allConfigurations = deps.configurationService.getAllConfigurations();\r\n    const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);\r\n    const allRoutesConfiguredFlat = [].concat(...allRoutesConfigured);\r\n    if (allRoutesConfiguredFlat.length === 0) {\r\n        deps.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);\r\n        return next(req);\r\n    }\r\n    const { matchingConfig, matchingRoute } = deps.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);\r\n    if (!matchingConfig) {\r\n        deps.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);\r\n        return next(req);\r\n    }\r\n    deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);\r\n    const token = deps.authStateService.getAccessToken(matchingConfig);\r\n    if (!token) {\r\n        deps.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);\r\n        return next(req);\r\n    }\r\n    deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\r\n    req = req.clone({\r\n        headers: req.headers.set('Authorization', 'Bearer ' + token),\r\n    });\r\n    return next(req);\r\n}\n\n// Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AbstractLoggerService, AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, ConfigurationService, EventTypes, LogLevel, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, ValidationResult, authInterceptor, createStaticLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}